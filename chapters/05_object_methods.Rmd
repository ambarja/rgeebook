# (PART) Objects and Methods {-}

```{r, include = FALSE}
source("common.R")
```


# Objects and Methods Overview

<div style="text-align: justify">

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Image

## Image Overview {-}

As mentioned in the [Get Started]() doc, raster data are represented as Image objects in Earth Engine. Images are composed of one or more bands and each band has its own name, data type, scale, mask and projection. Each image has metadata stored as a set of properties.

### `ee$Image` constructor {-}

Images can be loaded by pasting an Earth Engine asset ID into the `ee$Image` constructor. You can find image IDs in the [data catalog](https://developers.google.com/earth-engine/datasets). For example, to load [JAXA's ALOS DSM](https://developers.google.com/earth-engine/datasets/catalog/JAXA_ALOS_AW3D30_V3_2):

```{r, eval=FALSE}
loadedImage <- ee$Image('JAXA/ALOS/AW3D30/V2_2')
```

Note that finding an image through the Code Editor search tool is equivalent. When you import the asset, the image construction code is written for you in the imports section of the Code Editor. You can also use a personal asset ID as shown in this doc.

### Get an `ee$Image` from an `ee$ImageCollection` {-}

The standard way to get an image out of a collection is to filter the collection, with filters in order of decreasing specificity. For example, to get an image out of the [Sentinel-2 surface reflectance collection](https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR):

```{r, eval=FALSE}
first <- ee$ImageCollection('COPERNICUS/S2_SR')$
  filterBounds(ee$Geometry$Point(-70.48, 43.3631))$
  filterDate('2019-01-01', '2019-12-31')$
  sort('CLOUDY_PIXEL_PERCENTAGE')$
  first()
vizParams <- list(bands = c('B4', 'B3', 'B2'),
                  min = 0, 
                  max = 2000)
Map$centerObject(first, 11);
Map$addLayer(first, vizParams, 'first')
```

Note that the `sort` is *after* the filters. Avoid sorting the entire collection.

### Images from Cloud GeoTIFFs {-}

You can use `ee$Image$loadGeoTIFF()` to load images from Cloud Optimized GeoTIFFs in Google Cloud Storage. For example, the [public Landsat dataset](https://console.cloud.google.com/marketplace/details/usgs-public-data/landast) hosted in Google Cloud contains [this GeoTIFF](https://console.cloud.google.com/storage/browser/_details/gcp-public-data-landsat/LC08/01/001/002/LC08_L1GT_001002_20160817_20170322_01_T2/LC08_L1GT_001002_20160817_20170322_01_T2_B5.TIF), corresponding to band 5 from a Landsat 8 scene. You can load this image from Cloud Storage using `ee$Image$loadGeoTIFF()`:

```{r, eval=FALSE}
uri <- 'gs://gcp-public-data-landsat/LC08/01/001/002/' +
    'LC08_L1GT_001002_20160817_20170322_01_T2/' +
    'LC08_L1GT_001002_20160817_20170322_01_T2_B5.TIF'
cloudImage <- ee$Image$loadGeoTIFF(uri)
print(cloudImage)
```

Note that if you want to reload a Cloud Optimized GeoTIFF that you [export from Earth Engine to Cloud Storage](), when you do the export, set `cloudOptimized` to **true** as described [here]().

### Constant images {-}

In addition to loading images by ID, you can also create images from constants, lists or other suitable Earth Engine objects. The following illustrates methods for creating images, getting band subsets, and manipulating bands:

```{r, eval=FALSE}
## Create a constant image.
image1 <- ee$Image(1)
print(image1)

## Concatenate two images into one multi-band image.
image2 <- ee$Image(2)
image3 <- ee$Image$cat(c(image1, image2))
print(image3)

## Create a multi-band image from a list of constants.
multiband <- ee$Image(c(1, 2, 3))
print(multiband)

## Select and (optionally) rename bands.
renamed = multiband$select(
  c('constant', 'constant_1', 'constant_2'), ## old names
  c('band1', 'band2', 'band3')               ## new names
)
print(renamed)

## Add bands to an image.
image4 <- image3$addBands(ee$Image(42));
print(image4)
```











































## Image Visualization {-}

The are a number of `ee$Image` methods that produce RGB visual representations of image data, for example: `visualize()`, `getThumbURL()`, `getMap()`, `getMapId()` (used in Colab Folium map display) and, `Map$addLayer()` (used in Code Editor map display, not available for Python). By default these methods assign the first three bands to red, green and blue, respectively. The default stretch is based on the type of data in the bands (e.g. floats are stretched in [0, 1], 16-bit data are stretched to the full range of possible values), which may or may not be suitable. To achieve desired visualization effects, you can provide visualization parameters:

| Parameter| Description | Type | 
|--|:--|--|
| *bands* |Comma-delimited list of three band names to be mapped to RGB| list    |
| *min*  | Value(s) to map to 0       | number or list of three numbers, one for each band    | 
| *max*   | Value(s) to map to 255 | number or list of three numbers, one for each band       | 
| *gain*  | Value(s) by which to multiply each pixel value|number or list of three numbers, one for each band | 
| *bias*  | Value(s) to add to each DN  | number or list of three numbers, one for each band  | 
| *gamma* | Gamma correction factor(s)  |number or list of three numbers, one for each band   | 
| *palette* | 	List of CSS-style color strings (single-band images only)  | comma-separated list of hex strings|
| *opacity* | The opacity of the layer (0.0 is fully transparent and 1.0 is fully opaque)| number |
| *format*  | Either "jpg" or "png"  | string |


### RGB composites {-}    

The following illustrates the use of parameters to style a Landsat 8 image as a false-color composite:

```{r, eval=FALSE}
## Load an image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')

## Define the visualization parameters.
vizParams <- list(bands = c('B5', 'B4', 'B3'),
  min = 0,
  max = 0.5,
  gamma = c(0.95, 1.1, 1)
)
## Center the map and display the image.
Map$setCenter(-122.1899, 37.5010, 10); ## San Francisco Bay
Map$addLayer(image, vizParams, 'false color composite')
```

In this example, band `'B5'` is assigned to red, `'B4'` is assigned to green, and `'B3'` is assigned to blue.
<center>
![Figure 1. Landsat 8 false color composite of San Francisco bay area, California, USA.](F:/rgeebook/images/chapter_05/figure_01.png){width=670px}




### Color palettes {-}

To display a single band of an image in color, set the palette parameter with a color ramp represented by a list of CSS-style color strings. (See this reference for more information). The following example illustrates how to use colors from cyan ('00FFFF') to blue ('0000FF') to render a Normalized Difference Water Index (NDWI) image:

```{r, eval=FALSE}
## Load an image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')

## Create an NDWI image, define visualization parameters and display.
ndwi <- image$normalizedDifference(c('B3', 'B5'))
ndwiViz <- list(
  min = 0.5, 
  max = 1, 
  palette = c('00FFFF', '0000FF')
)
Map$addLayer(ndwi, ndwiViz, 'NDWI')
```

In this example, note that the min and max parameters indicate the range of pixel values to which the palette should be applied. Intermediate values are linearly stretched.

<center>
![Figure 2. Landsat 8 NDWI, San Francisco bay area, USA. Cyan are low values, blue are high values.](F:/rgeebook/images/chapter_05/figure_02.png){width=670px}

### Masking {-}

You can use `image$updateMask()` to set the opacity of individual pixels based on where pixels in a mask image are non-zero. Pixels equal to zero in the mask are excluded from computations and the opacity is set to 0 for display. The following example uses an NDWI threshold (see the [Relational Operations section]() for information on thresholds) to update the mask on the NDWI layer created previously:

```{r, eval=FALSE}
## Mask the non-watery parts of the image, where NDWI < 0.4.
ndwiMasked <- ndwi$updateMask(ndwi$gte(0.4))
Map$addLayer(ndwiMasked, ndwiViz, 'NDWI masked')
```

### Visualization images {-}

Use the `image.visualize()` method to convert an image into an 8-bit RGB image for display or export. For example, to convert the false-color composite and NDWI to 3-band display images, use:

```{r, eval=FALSE}
## Create visualization layers.
imageRGB <- image$visualize(list(
  bands = c('B5', 'B4', 'B3'), 
  max = 0.5
))

ndwiRGB <- ndwiMasked$visualize(list(
  min = 0.5,
  max = 1,
  palette = c('00FFFF', '0000FF'))
)
```

### Mosaicking {-}

You can use masking and `imageCollection.mosaic()` (see the Mosaicking section for information on mosaicking) to achieve various cartographic effects. The `mosaic()` method renders layers in the output image according to their order in the input collection. The following example uses `mosaic()` to combine the masked NDWI and the false color composite and obtain a new visualization:

```{r, eval=FALSE}
## Mosaic the visualization layers and display (or export).
mosaic <- ee$ImageCollection(list(imageRGB, ndwiRGB))$
  mosaic()
Map$addLayer(mosaic, {}, 'mosaic')
```

In this example, observe that a list of the two visualization images is provided to the `ImageCollection` constructor. The order of the list determines the order in which the images are rendered on the map.
<center>
![Figure 3. Mosaic of a Landsat 8 false color composite and NDWI. San Francisco bay area, USA.](F:/rgeebook/images/chapter_05/figure_03.png){width=670px}


### Clipping {-}

The `image$clip()` method is useful for achieving cartographic effects. The following example clips the mosaic created previously to an arbitrary buffer zone around the city of San Francisco:

```{r, eval=FALSE}
## Create a circle by drawing a 20000 meter buffer around a point.
roi <- ee$Geometry$Point(-122.4481, 37.7599)$buffer(20000);

## Display a clipped version of the mosaic.
Map$addLayer(mosaic$clip(roi))
```

In the previous example, note that the coordinates are provided to the `Geometry` constructor and the buffer length is specified as 20,000 meters. Learn more about geometries on the [Geometries page]().
<center>
![Figure 2. The mosaic shown above, clipped to a buffer around San Francisco, California, USA.](F:/rgeebook/images/chapter_05/figure_04.png){width=670px}




















### Rendering categorical maps {-}

Palettes are also useful for rendering discrete valued maps, for example a land cover map. In the case of multiple classes, use the palette to supply a different color for each class. (The `image$remap()` method may be useful in this context, to convert arbitrary labels to consecutive integers). The following example uses a palette to render land cover categories:

```{r, eval=FALSE}
## Load 2012 MODIS land cover and select the IGBP classification.
cover <- ee$Image('MODIS/051/MCD12Q1/2012_01_01')$
  select('Land_Cover_Type_1')

## Define a palette for the 18 distinct land cover classes.
igbpPalette <- list(
  'aec3d4', ## water
  '152106', '225129', '369b47', '30eb5b', '387242', ## forest
  '6a2325', 'c3aa69', 'b76031', 'd9903d', '91af40',  ## shrub, grass
  '111149', ## wetlands
  'cdb33b', ## croplands
  'cc0013', ## urban
  '33280d', ## crop mosaic
  'd7cdcc', ## snow and ice
  'f7e084', ## barren
  '6f6f6f'  ## tundra
)

## Specify the min and max labels and the color palette matching the labels.
Map$setCenter(-99.229, 40.413, 5);
Map$addLayer(cover,
             {min: 0, max: 17, palette: igbpPalette},
             'IGBP classification');
```
<center>
![Figure 4. MODIS 2012 land cover using the IGBP classification..](F:/rgeebook/images/chapter_05/figure_03.png){width=670px}
</p>


### Styled Layer Descriptors {-}

You can use a Styled Layer Descriptor ([SLD]()) to render imagery for display. Provide `image$sldStyle()` with an XML description of the symbolization and coloring of the image, specifically the `RasterSymbolizer` element. Learn more about the `RasterSymbolizer` element [here](). For example, to render the land cover map described in the Rendering categorical maps section with an SLD, use:

```{r, eval=FALSE}
cover <- ee$Image('MODIS/051/MCD12Q1/2012_01_01')$select('Land_Cover_Type_1')

## Define an SLD style of discrete intervals to apply to the image.
sld_intervals <-
'<RasterSymbolizer>' +
  '<ColorMap type="intervals" extended="false">' +
    '<ColorMapEntry color="#aec3d4" quantity="0" label="Water"/>' +
    '<ColorMapEntry color="#152106" quantity="1" label="Evergreen Needleleaf Forest"/>' +
    '<ColorMapEntry color="#225129" quantity="2" label="Evergreen Broadleaf Forest"/>' +
    '<ColorMapEntry color="#369b47" quantity="3" label="Deciduous Needleleaf Forest"/>' +
    '<ColorMapEntry color="#30eb5b" quantity="4" label="Deciduous Broadleaf Forest"/>' +
    '<ColorMapEntry color="#387242" quantity="5" label="Mixed Deciduous Forest"/>' +
    '<ColorMapEntry color="#6a2325" quantity="6" label="Closed Shrubland"/>' +
    '<ColorMapEntry color="#c3aa69" quantity="7" label="Open Shrubland"/>' +
    '<ColorMapEntry color="#b76031" quantity="8" label="Woody Savanna"/>' +
    '<ColorMapEntry color="#d9903d" quantity="9" label="Savanna"/>' +
    '<ColorMapEntry color="#91af40" quantity="10" label="Grassland"/>' +
    '<ColorMapEntry color="#111149" quantity="11" label="Permanent Wetland"/>' +
    '<ColorMapEntry color="#cdb33b" quantity="12" label="Cropland"/>' +
    '<ColorMapEntry color="#cc0013" quantity="13" label="Urban"/>' +
    '<ColorMapEntry color="#33280d" quantity="14" label="Crop, Natural Veg. Mosaic"/>' +
    '<ColorMapEntry color="#d7cdcc" quantity="15" label="Permanent Snow, Ice"/>' +
    '<ColorMapEntry color="#f7e084" quantity="16" label="Barren, Desert"/>' +
    '<ColorMapEntry color="#6f6f6f" quantity="17" label="Tundra"/>' +
  '</ColorMap>' +
'</RasterSymbolizer>'

Map$addLayer(cover$sldStyle(sld_intervals), {}, 'IGBP classification styled');
```

To create a visualization image with a color ramp, set the type of the ColorMap to 'ramp'. The following example compares the 'interval' and 'ramp' types for rendering a DEM:

```{r, eval=FALSE}
## Load SRTM Digital Elevation Model data.
image <- ee$Image('CGIAR/SRTM90_V4')

## Define an SLD style of discrete intervals to apply to the image.
var sld_intervals <-
  '<RasterSymbolizer>' +
    '<ColorMap type="intervals" extended="false" >' +
      '<ColorMapEntry color="#0000ff" quantity="0" label="0"/>' +
      '<ColorMapEntry color="#00ff00" quantity="100" label="1-100" />' +
      '<ColorMapEntry color="#007f30" quantity="200" label="110-200" />' +
      '<ColorMapEntry color="#30b855" quantity="300" label="210-300" />' +
      '<ColorMapEntry color="#ff0000" quantity="400" label="310-400" />' +
      '<ColorMapEntry color="#ffff00" quantity="1000" label="410-1000" />' +
    '</ColorMap>' +
  '</RasterSymbolizer>'

## Define an sld style color ramp to apply to the image.
sld_ramp <-
  '<RasterSymbolizer>' +
    '<ColorMap type="ramp" extended="false" >' +
      '<ColorMapEntry color="#0000ff" quantity="0" label="0"/>' +
      '<ColorMapEntry color="#00ff00" quantity="100" label="100" />' +
      '<ColorMapEntry color="#007f30" quantity="200" label="200" />' +
      '<ColorMapEntry color="#30b855" quantity="300" label="300" />' +
      '<ColorMapEntry color="#ff0000" quantity="400" label="400" />' +
      '<ColorMapEntry color="#ffff00" quantity="500" label="500" />' +
    '</ColorMap>' +
  '</RasterSymbolizer>'

## Add the image to the map using both the color ramp and interval schemes.
Map$setCenter(-76.8054, 42.0289, 8)
Map$addLayer(image$sldStyle(sld_intervals), {}, 'SLD intervals')
Map$addLayer(image$sldStyle(sld_ramp), {}, 'SLD ramp')
```

SLDs are also useful for stretching pixel values to improve visualizations of continuous data. For example, the following code compares the results of an arbitrary linear stretch with a min-max 'Normalization' and a 'Histogram' equalization:

```{r, eval=FALSE}
## Load a Landsat 8 raw image.
image = ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')

## Define a RasterSymbolizer element with '_enhance_' for a placeholder.
template_sld <-
  '<RasterSymbolizer>' +
    '<ContrastEnhancement><_enhance_/></ContrastEnhancement>' +
    '<ChannelSelection>' +
      '<RedChannel>' +
        '<SourceChannelName>B5</SourceChannelName>' +
      '</RedChannel>' +
      '<GreenChannel>' +
        '<SourceChannelName>B4</SourceChannelName>' +
      '</GreenChannel>' +
      '<BlueChannel>' +
        '<SourceChannelName>B3</SourceChannelName>' +
      '</BlueChannel>' +
    '</ChannelSelection>' +
  '</RasterSymbolizer>'

## Get SLDs with different enhancements.
equalize_sld <- template_sld.replace('_enhance_', 'Histogram')
normalize_sld <- template_sld.replace('_enhance_', 'Normalize')

## Display the results.
Map$centerObject(image, 10)
Map$addLayer(image, {bands: ['B5', 'B4', 'B3'], min: 0, max: 15000}, 'Linear')
Map$addLayer(image.sldStyle(equalize_sld), {}, 'Equalized')
Map$addLayer(image.sldStyle(normalize_sld), {}, 'Normalized')
```

Points of note in reference to using SLDs in Earth Engine:

- OGC SLD 1.0 and OGC SE 1.1 are supported.
- The XML document passed in can be complete, or just the RasterSymbolizer element and down.
- Bands may be selected by their Earth Engine names or index ('1', '2', ...).
- The Histogram and Normalize contrast stretch mechanisms are not supported for floating point imagery.
- Opacity is only taken into account when it is 0.0 (transparent). Non-zero opacity values are treated as completely opaque.
- The OverlapBehavior definition is currently ignored.
- The ShadedRelief mechanism is not currently supported.
- The ImageOutline mechanism is not currently supported.
- The Geometry element is ignored.
- The output image will have histogram_bandname metadata if histogram equalization or normalization is requested.

### Thumbnail images {-}

Use the `ee$Image.getThumbURL()` method to generate a PNG or JPEG thumbnail image for an `ee$Image` object. Printing the outcome of an expression ending with a call to `getThumbURL()` results in a URL being printed. Visiting the URL sets Earth Engine servers to work on generating the requested thumbnail on-the-fly. The image is displayed in a browser when processing completes. It can be downloaded by selecting appropriate options from the image's right-click context menu.
 
 -**Note**: *The authorization token to process the thumbnail lasts 2 hours. Until it expires, anyone  with the authorization token can generate the image.*
<center>
![Figure 5. SRTM digital elevation model displayed as a PNG thumbnail in a browser.](F:/rgeebook/images/chapter_05/figure_05.png){width=670px}
</div>



The `getThumbURL()` method includes parameters, described in the visualization parameters table above. Additionally, it takes optional `dimensions`, `region`, and `crs` arguments that control the spatial extent, size, and display projection of the thumbnail.

| Parameter| Description | Type | 
|--|:--|--|
| *dimensions* |Thumbnail dimensions in pixel units. If a single integer is provided, it defines the size of the image's larger aspect dimension and scales the smaller dimension proportionally. Defaults to 512 pixels for the larger image aspect dimension.| A single integer or string in the format: 'WIDTHxHEIGHT'    |
| *region*  | The geospatial region of the image to render. The whole image by default, or the bounds of a provided geometry.|GeoJSON or a 2-D list of at least three point coordinates that define a linear ring | 
| *crs*   | The target projection e.g. 'EPSG:3857'. Defaults to WGS84 ('EPSG:4326').|   String  |
| *format*  | 	Defines thumbnail format as either PNG or JPEG. The default PNG format is implemented as RGBA, where the alpha channel represents valid and invalid pixels, defined by the image's mask(). Invalid pixels are transparent. The optional JPEG format is implemented as RGB, where invalid image pixels are zero filled across RGB channels.|String; either 'png' or 'jpg'  |



*Caution*: **The *'WIDTHxHEIGHT'* dimensions argument can alter the original aspect ratio of the data or region extent.**


A single-band image will default to grayscale unless a `palette` argument is supplied. A multi-band image will default to RGB visualization of the first three bands, unless a `bands` argument is supplied. If only two bands are provided, the first band will map to red, the second to blue, and the green channel will be zero filled.

The following are a series of examples demonstrating various combinations of `getThumbURL()` parameter arguments. Click on the URLs printed when you run this script to view the thumbnails.

```{r, eval=FALSE}
## Fetch a digital elevation model.
image <- ee$Image('CGIAR/SRTM90_V4')

## Request a default thumbnail of the DEM with defined linear stretch.
## Set masked pixels (ocean) to 1000 so they map as gray.
thumbnail1 <- image$unmask(1000)$getThumbURL({
  'min': 0,
  'max': 3000,
  'dimensions': 500,
})
print('Default extent:', thumbnail1)

## Specify region by rectangle, define palette, set larger aspect dimension size.
thumbnail2 <- image$getThumbURL({
  'min': 0,
  'max': 3000,
  'palette': ['00A600','63C600','E6E600','E9BD3A','ECB176','EFC2B3','F2F2F2'],
  'dimensions': 500,
  'region': ee.Geometry.Rectangle([-84.6, -55.9, -32.9, 15.7]),
})
print('Rectangle region and palette:', thumbnail2);

## Specify region by a linear ring and set display CRS as Web Mercator.
thumbnail3 <- image.getThumbURL({
  'min': 0,
  'max': 3000,
  'palette': ['00A600','63C600','E6E600','E9BD3A','ECB176','EFC2B3','F2F2F2'],
  'region': ee.Geometry.LinearRing([[-84.6, 15.7], [-84.6, -55.9], [-32.9, -55.9]]),
  'dimensions': 500,
  'crs': 'EPSG:3857'
})
print('Linear ring region and specified crs', thumbnail3);
```

 
- **Note**: Thumbnail images are also available as UI elements (Code Editor only), see: [_ui.Thumbnail_]().*

- **Note**: `getThumbURL` is intended as a method for producing preview images you might include in presentations, websites, and social media posts. Its size limitation is 100,000,000 pixels and the browser can timeout for complicated requests. If you want a large image or have a complex process, see the [Exporting Data page]().

## Image Information and Metadata {-}

Print image objects to explore band names, projection information, properties, and other metadata. The following examples demonstrate printing the entire set of image metadata as well as requesting specific metadata elements programmatically.

### Getting metadata {-}

```{r, eval=FALSE}
## Load an image.
image <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')

## Display all metadata.
print('All metadata:', image)

## Get information about the bands as a list.
var bandNames <- image$bandNames()
print('Band names:', bandNames)  ## ee$List of band names

## Get projection information from band 1.
b1proj <- image$select('B1')$projection()
print('Band 1 projection:', b1proj)  ## ee$Projection object

## Get scale (in meters) information from band 1.
b1scale <- image$select('B1')$projection()$nominalScale()
print('Band 1 scale:', b1scale)  ## ee$Number

## Note that different bands can have different projections and scale.
b8scale <- image$select('B8')$projection()$nominalScale()
print('Band 8 scale:', b8scale)  ## ee$Number

## Get a list of all metadata properties.
properties <- image$propertyNames()
print('Metadata properties:', properties)  ## ee$List of metadata properties

## Get a specific metadata property.
cloudiness <- image$get('CLOUD_COVER')
print('CLOUD_COVER:', cloudiness)  ## ee$Number

## Get version number (ingestion timestamp as microseconds since Unix epoch).
version <- image$get('system:version')
print('Version:', version)  ## ee$Number
print('Version (as ingestion date):',
      ee$Date(ee$Number(version)$divide(1000)))  ## ee$Date

## Get the timestamp and convert it to a date.
date <- ee$Date(image$get('system:time_start'))
print('Timestamp:', date)  ## ee$Date

```










## Mathematical Operations {-}

Image math can be performed using operators like `add()` and `subtract()`, but for complex computations with more than a couple of terms, the expression() function provides a good alternative. See the following sections for more information on [operators]() and [expressions]().

### Operators {-}

Math operators perform basic arithmetic operations on image bands. They take two inputs: either two images or one image and a constant term, which is interpreted as a single-band constant image with no masked pixels. Operations are performed per pixel for each band.

As a simple example, consider the task of calculating the Normalized Difference Vegetation Index (NDVI) using Landsat imagery, where `add()`, `subtract()`, and `divide()` operators are used:

```{r, eval=FALSE}
## Load a 5-year Landsat 7 composite 1999-2003.
landsat1999 <- ee$Image('LANDSAT/LE7_TOA_5YEAR/1999_2003')

## Compute NDVI.
ndvi1999 <- landsat1999$select('B4')$subtract(landsat1999$select('B3'))$
  divide(landsat1999$select('B4')$add(landsat1999$select('B3')))
```

**Note**: the normalized difference operation is available as a shortcut method: [_normalizedDifference()_]().

Only the intersection of unmasked pixels between the two inputs are considered and returned as unmasked, all else are masked. In general, if either input has only one band, then it is used against all the bands in the other input. If the inputs have the same number of bands, but not the same names, they're used pairwise in the natural order. The output bands are named for the longer of the two inputs, or if they're equal in length, in the first input's order. The type of the output pixels is the union of the input types.

The following example of multi-band image subtraction demonstrates how bands are matched automatically, resulting in a “change vector” for each pixel for each co-occurring band.

```{r, eval=FALSE}
## Load a 5-year Landsat 7 composite 2008-2012.
landsat2008 <- ee$Image('LANDSAT/LE7_TOA_5YEAR/2008_2012')

## Compute multi-band difference between the 2008-2012 composite and the
## previously loaded 1999-2003 composite.
diff <- landsat2008$subtract(landsat1999)
Map$addLayer(diff,
             {bands: ['B4', 'B3', 'B2'],
               min: -32, 
               max: 32}, 
             'difference')

## Compute the squared difference in each band.
squaredDifference <- diff$pow(2);
Map$addLayer(squaredDifference,
             {bands: ['B4', 'B3', 'B2'], max: 1000}, 'squared diff.')
```

In the second part of this example, the squared difference is computed using image.pow(2). For the complete list of mathematical operators handling basic arithmetic, trigonometry, exponentiation, rounding, casting, bitwise operations and more, see the [API documentation]().

### Expresions {-}

To implement more complex mathematical expressions, consider using image.expression(), which parses a text representation of a math operation. The following example uses expression() to compute the Enhanced Vegetation Index (EVI):

```{r, eval=FALSE}
## Load a Landsat 8 image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')

## Compute the EVI using an expression.
evi <- image.expression(
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('B5'),
      'RED': image.select('B4'),
      'BLUE': image.select('B2')
})

Map$centerObject(image, 9)
Map$addLayer(evi, {min: -1, max: 1, palette: ['FF0000', '00FF00']})
```

Observe that the first argument to `expression()` is the textual representation of the math operation, the second argument is a dictionary where the keys are variable names used in the expression and the values are the image bands to which the variables should be mapped. Bands in the image may be referred to as `b("band name")` or `b(index)`, for example `b(0)`, instead of providing the dictionary. Bands can be defined from images other than the input when using the band map dictionary. Note that `expression()` uses "floor division", which discards the remainder and returns an integer when two integers are divided. For example `10 / 20 = 0`. To change this behavior, multiply one of the operands by `1.0: 10 * 1.0 / 20 = 0.5`. Only the intersection of unmasked pixels are considered and returned as unmasked when bands from more than one source image are evaluated. Supported expression operators are listed in the following table.

**Operators for expression()**

| Type | Symbol | Name | 
|--|:--|--|
| *Arithmetic*  |	+ - * / % **      | Add, Subtract, Multiply, Divide, Modulus, Exponent    |
| *Relational*  | 	== != < > <= >= | Equal, Not Equal, Less Than, Greater than, etc.       | 
| *Logical*     | && `||` ! ^       |                     And, Or, Not, Xor                 |
| *Ternary*     | 		? :           |                      If then else                     |

## Relational, Conditional, and Boolean Operations {-}

`ee$Image` objects have a set of relational, conditional, and boolean methods for constructing decision-making expressions. The results of these methods are useful for limiting analysis to certain pixels or regions through masking, developing classified maps, and value reassignment.

### Relational and boolean operators {-}

- **Relational** methods include:
`eq()`, `gt()`, `gte()`, `lt()`, and `lte()`.

- **Boolean** methods include:
`and()`,`or()`, and `not()`.

To perform per-pixel comparisons between images, use relational operators. To extract urbanized areas in an image, this example uses relational operators to threshold spectral indices, combining the thresholds with the and operator:

```{r, eval=FALSE}
## Load a Landsat 8 image.
image <- ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')

## Create NDVI and NDWI spectral indices.
ndvi <- image$normalizedDifference(c('B5', 'B4'))
ndwi <- image$normalizedDifference(c('B3', 'B5'))
## Create a binary layer using logical operations.
bare <- ndvi$lt(0.2)$and(ndwi$lt(0))

## Mask and display the binary layer.
Map$setCenter(-122.3578, 37.7726, 12)
Map$setOptions('satellite')
Map$addLayer(bare$selfMask(), {}, 'bare')
```

As illustrated by this example, the output of relational and boolean operators is either true (1) or false (0). To mask the 0's, you can mask the resultant binary image with itself using `selfMask()`.

<center>
![Figure 6. Low NDVI and low NDWI (white) from Landsat 8, San Francisco, California, USA.](F:/rgeebook/images/chapter_05/figure_06.png){width=670px}

<div style="text-align: justify">

The binary images that are returned by relational and boolean operators can be used with mathematical operators. This example creates zones of urbanization in a nighttime lights image using relational operators and `add()`:

```{r, eval=FALSE}
## Load a 2012 nightlights image.
nl2012 <- ee$Image('NOAA/DMSP-OLS/NIGHTTIME_LIGHTS/F182012')
lights <- nl2012$select('stable_lights')

## Define arbitrary thresholds on the 6-bit stable lights band.
zones <- lights$gt(30)$add(lights$gt(55))$add(lights$gt(62))

## Display the thresholded image as three distinct zones near Paris.
palette <-c('000000', '0000FF', '00FF00', 'FF0000')
Map$setCenter(2.373, 48.8683, 8)
Map$addLayer(zones, {min: 0, max: 3, palette: palette}, 'development zones')
```
<div style="text-align: justify">
### Conditional operators {-}

Note that the code in the previous example is equivalent to using a [ternary operator]() implemented by `expression()`:

```{r, eval=FALSE}
## Create zones using an expression, display.
zonesExp <- nl2012.expression(
    "(b('stable_lights') > 62) ? 3" +
      ": (b('stable_lights') > 55) ? 2" +
        ": (b('stable_lights') > 30) ? 1" +
          ": 0"
)
Map$addLayer(zonesExp,
             {min: 0, max: 3, palette: palette},
             'development zones (ternary)');
```

Observe that in the previous expression example, the band of interest is referenced using the b() function, rather than a dictionary of variable names. Learn more about image expressions on [this page](). Using either mathematical operators or an expression will produce the same result.

<center>
![Figure 7. Arbitrary zones of 2012 nightlights imagery for Paris, France.](F:/rgeebook/images/chapter_05/figure_07.png){width=670px}
</p>

<div style="text-align: justify">

Another way to implement conditional operations on images is with the `where()` operator. Consider the need to replace masked pixels with some other data. In the following example, cloudy pixels are replaced by pixels from a cloud-free image using `where()`:

```{r, eval=FALSE}
## Load a cloudy Landsat 8 image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20130603')
Map$addLayer(image,
             {bands: ['B5', 'B4', 'B3'], min: 0, max: 0.5},
             'original image')

## Load another image to replace the cloudy pixels.
replacement <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20130416')

## Compute a cloud score band.
cloud <- ee$Algorithms$Landsat$simpleCloudScore(image)$select('cloud')

## Set cloudy pixels to the other image.
replaced <- image$where(cloud$gt(10), replacement)

## Display the result.
Map$centerObject(image, 9);
Map$addLayer(replaced,
             {bands: ['B5', 'B4', 'B3'], min: 0, max: 0.5},
             'clouds replaced');
```

In this example, observe the use of the `simpleCloudScore()` algorithm. This algorithm ranks pixels by cloudiness on a scale of 0-100, with 100 most cloudy. Learn more about `simpleCloudScore()` on the [Landsat Algorithms page]().


## Convolutions {-}

To perform linear convolutions on images, use `image.convolve()`. The only argument to convolve is an ee.Kernel which is specified by a shape and the weights in the kernel. Each pixel of the image output by `convolve()` is the linear combination of the kernel values and the input image pixels covered by the kernel. The kernels are applied to each band individually. For example, you might want to use a low-pass (smoothing) kernel to remove high-frequency information. The following illustrates a 15x15 low-pass kernel applied to a Landsat 8 image:

```{r, eval=FALSE}
## Load and display an image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')
vizParams <- list(bands = c('B5', 'B4', 'B3'),
                  max = 0.5)
Map$setCenter(-121.9785, 37.8694, 11)
Map$addLayer(image,vizParams, 'input image')

## Define a boxcar or low-pass kernel.
boxcar <- ee$Kernel$square(list(
  radius = 7,
  units = 'pixels', 
  normalize = TRUE
))

## Smooth the image by convolving with the boxcar kernel.
smooth <- image$convolve(boxcar)
Map$addLayer(smooth, {bands: ['B5', 'B4', 'B3'], max: 0.5}, 'smoothed')
```


The output of convolution with the low-pass filter should look something like Figure 8. Observe that the arguments to the kernel determine its size and coefficients. Specifically, with the `units` parameter set to pixels, the radius parameter specifies the number of pixels from the center that the kernel will cover. If `normalize` is set to `true`, the kernel coefficients will sum to one. If the `magnitude` parameter is set, the kernel coefficients will be multiplied by the magnitude (if `normalize` is also true, the coefficients will sum to `magnitude`). If there is a negative value in any of the kernel coefficients, setting `normalize` to true will make the coefficients sum to zero.

<center>
![Figure 8. Landsat 8 image convolved with a smoothing kernel. San Francisco Bay area, California, USA.](F:/rgeebook/images/chapter_05/figure_08.png){width=670px}


<div style="text-align: justify">
Use other kernels to achieve the desired image processing effect. This example uses a Laplacian kernel for isotropic edge detection:

```{r, eval=FALSE}
## Define a Laplacian, or edge-detection kernel.
laplacian <- ee$Kernel$laplacian8({ normalize: false })

## Apply the edge-detection kernel.
edgy <- image$convolve(laplacian)
Map$addLayer(edgy,
             {bands: ['B5', 'B4', 'B3'], max: 0.5, format: 'png'},
             'edges')
```


Note the format specifier in the visualization parameters. Earth Engine sends display tiles to the Code Editor in JPEG format for efficiency, however edge tiles are sent in PNG format to handle transparency of pixels outside the image boundary. When a visual discontinuity results, setting the format to PNG results in a consistent display. The result of convolving with the Laplacian edge detection kernel should look something like Figure 9.

<center>
![Figure 9. Landsat 8 image convolved with a Laplacian edge detection kernel. San Francisco Bay area, California,USA.](F:/rgeebook/images/chapter_05/figure_09.png){width=670px}

<div style="text-align: justify">

There are also anisotropic edge detection kernels (e.g. Sobel, Prewitt, Roberts), the direction of which can be changed with `kernel$rotate()`. Other low pass kernels include a Gaussian kernel and kernels of various shape with uniform weights. To create kernels with arbitrarily defined weights and shape, use `ee$Kernel$fixed()`. For example, this code creates a 9x9 kernel of 1’s with a zero in the middle:

```{r, eval=FALSE}
## Create a list of weights for a 9x9 kernel.
row <- c(1, 1, 1, 1, 1, 1, 1, 1, 1)

## The center of the kernel is zero.
centerRow <- c(1, 1, 1, 1, 0, 1, 1, 1, 1)

## Assemble a list of lists: the 9x9 kernel weights as a 2-D matrix.
rows <- c(row, row, row, row, centerRow, row, row, row, row)

## Create the kernel from the weights.
kernel <- ee$Kernel$fixed(9, 9, rows, -4, -4, false)
print(kernel)
```

<div style="text-align: justify">
## Morphological Operations {-}

Earth Engine implements morphological operations as focal operations, specifically `focalMax()`, `focalMin()`, `focalMedian()`, and `focalMode()` instance methods in the `Image` class. (These are shortcuts for the more general reduceNeighborhood(), which can input the pixels in a kernel to any reducer with a numeric output. See this [page]() for more information on reducing neighborhoods). The morphological operators are useful for performing operations such as erosion, dilation, opening and closing. For example, to perform an [opening operation](), use `focalMin()` followed by `focalMax()`:

```{r, eval=FALSE}
## Load a Landsat 8 image, select the NIR band, threshold, display.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')$
  select(4).gt(0.2);
Map$setCenter(-122.1899, 37.5010, 13)
Map$addLayer(image, {}, 'NIR threshold')

## Define a kernel.
kernel <- ee$Kernel$circle(radius = 1)

## Perform an erosion followed by a dilation, display.
opened <- image$
  focalMin({kernel: kernel, iterations: 2})$
  focalMax({kernel: kernel, iterations: 2})
Map.addLayer(opened, {}, 'opened')
```

Note that in the previous example, a kernel argument is provided to the morphological operator. The pixels covered by non-zero elements of the kernel are used in the computation. The iterations argument indicates how many times to apply the operator.

<div style="text-align: justify">
## Gradients {-}

You can compute the gradient of each band of an image with `image.gradient()`. For example, the following code computes the gradient magnitude and direction of the Landsat 8 panchromatic band:

```{r, eval=FALSE}
## Load a Landsat 8 image and select the panchromatic band.
image <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')$select('B8')

## Compute the image gradient in the X and Y directions.
xyGrad <- image$gradient()

## Compute the magnitude of the gradient.
gradient <- xyGrad$select('x')$pow(2)$
  add(xyGrad$select('y')$pow(2))$sqrt()

## Compute the direction of the gradient.
direction <- xyGrad$select('y')$atan2(xyGrad$select('x'))

## Display the results.
Map$setCenter(-122.054, 37.7295, 10);
Map$addLayer(direction, list(min: -2, max: 2, format: 'png'), 'direction')
Map$addLayer(gradient, list(min: -7, max: 7, format: 'png'), 'gradient')
```

Note that `gradient()` outputs two bands: the gradient in the X-direction and the gradient in the Y-direction. As shown in the example, the two directions can be combined to get gradient magnitude and direction. The magnitude should look something like Figure 10.
<center>
![Figure 10. Panchromatic gradient magnitude for the Landsat 8 imagery over the San Francisco Bay area, California, USA.](F:/rgeebook/images/chapter_05/figure_10.png){width=670px}

</p>


<div style="text-align: justify">

## Edge detection {-}

[Edge detection](https://en.wikipedia.org/wiki/Edge_detection) is applicable to a wide range of image processing tasks. In addition to the edge detection kernels described in the [convolutions section](), there are several specialized edge detection algorithms in Earth Engine. The Canny edge detection algorithm ([Canny 1986](https://ieeexplore.ieee.org/document/)) uses four separate filters to identify the diagonal, vertical, and horizontal edges. The calculation extracts the first derivative value for the horizontal and vertical directions and computes the gradient magnitude. Gradients of smaller magnitude are suppressed. To eliminate high-frequency noise, optionally pre-filter the image with a Gaussian kernel. For example:

```{r, eval=FALSE}
## Load a Landsat 8 image, select the panchromatic band.
image <- ee.$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')$select('B8')

## Perform Canny edge detection and display the result.
canny <- ee$Algorithms$CannyEdgeDetector(list(
  image = image, 
  threshold = 10, 
  sigma = 1)
  )
Map$setCenter(-122.054, 37.7295, 10)
Map$addLayer(canny, {}, 'canny')
```

Note that the `threshold` parameter determines the minimum gradient magnitude and the `sigma` parameter is the standard deviation (SD) of a Gaussian pre-filter to remove high-frequency noise. For line extraction from an edge detector, Earth Engine implements the Hough transform ([Duda and Hart 1972](https://dl.acm.org/doi/10.1145/361237.361242)). Continuing the previous example, extract lines from the Canny detector with:

```{r, eval=FALSE}
## Perform Hough transform of the Canny result and display.
hough <- ee$Algorithms$HoughTransform(canny, 256, 600, 100)
Map$addLayer(hough, {}, 'hough');
```

Another specialized algorithm in Earth Engine is `zeroCrossing()`. A zero-crossing is defined as any pixel where the right, bottom, or diagonal bottom-right pixel has the opposite sign. If any of these pixels is of opposite sign, the current pixel is set to 1 (zero-crossing); otherwise it's set to zero. To detect edges, the zero-crossings algorithm can be applied to an estimate of the image second derivative. The following demonstrates using `zeroCrossing()` for edge detection:

```{r, eval=FALSE}
## Load a Landsat 8 image, select the panchromatic band.
image <- ee$Image('LANDSAT/LC08/C01/T1/LC08_044034_20140318')$select('B8')
Map$addLayer(image, list(max: 12000))

## Define a "fat" Gaussian kernel.
fat <- ee$Kernel$gaussian(list(
  radius = 3,
  sigma = 3,
  units = 'pixels',
  normalize = true,
  magnitude = -1)
)

## Define a "skinny" Gaussian kernel.
skinny <- ee$Kernel$gaussian(list(
  radius = 3,
  sigma = 1,
  units = 'pixels',
  normalize = true)
)

## Compute a difference-of-Gaussians (DOG) kernel.
dog <- fat$add(skinny)

## Compute the zero crossings of the second derivative, display.
zeroXings <- image$convolve(dog)$zeroCrossing()
Map.setCenter(-122.054, 37.7295, 10)
Map.addLayer(zeroXings$selfMask(), list(palette = 'FF0000'), 'zero crossings')
```


The zero-crossings output for an area near the San Francisco, CA airport should look something like Figure 11.

<center>
![Figure 11. Zero-crossings output (red) with the Landsat 8 panchromatic band in the background for an area near the San Francisco, California airport (right).](F:/rgeebook/images/chapter_05/figure_11.png){width=670px}

<div style="text-align: justify">

## Spectral transformations {-}

There are several spectral transformation methods in Earth Engine. These include instance methods on images such as `normalizedDifference()`, `unmix()`, `rgbToHsv()` and `hsvToRgb()`.

### Pan sharpening {-}

Pan sharpening improves the resolution of a multiband image through enhancement provided by a corresponding panchromatic image with finer resolution. The `rgbToHsv()` and `hsvToRgb()` methods are useful for pan sharpening.  

```{r, eval=FALSE}
## Load a Landsat 8 top-of-atmosphere reflectance image.
image <- ee$Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')
Map$addLayer(
    image,
    list(bands = c('B4', 'B3', 'B2'), min = 0, max = 0.25, gamma = c(1.1, 1.1, 1)),
    'rgb')

## Convert the RGB bands to the HSV color space.
hsv <- image$select(c('B4', 'B3', 'B2'))$rgbToHsv()

## Swap in the panchromatic band and convert back to RGB.
sharpened <- ee$Image.cat([
  hsv$select('hue'), hsv$select('saturation'), image$select('B8')
])$hsvToRgb()

## Display the pan-sharpened result.
Map$setCenter(-122.44829, 37.76664, 13);
Map$addLayer(sharpened,
             list(min = 0, max = 0.25, gamma = c(1.3, 1.3, 1.3)),
             'pan-sharpened')
```

### Spectral unmixing {-}

Spectral unmixing is implemented in Earth Engine as the `image.unmix()` method. (For more flexible methods, see the [Array Transformations page]()). The following is an example of unmixing Landsat 5 with predetermined urban, vegetation and water endmembers:

```{r, eval=FALSE}
## Load a Landsat 5 image and select the bands we want to unmix.
bands <- ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']
image <- ee$Image('LANDSAT/LT05/C01/T1/LT05_044034_20080214')$
  select(bands)
Map$setCenter(-122.1899, 37.5010, 10); ## San Francisco Bay
Map$addLayer(image, list(bands = c('B4', 'B3', 'B2'), min = 0, max = 128), 'image')

## Define spectral endmembers.
urban <- c(88, 42, 48, 38, 86, 115, 59)
veg <- c(50, 21, 20, 35, 50, 110, 23)
water <- c(51, 20, 14, 9, 7, 116, 4)

## Unmix the image.
fractions <- image$unmix(c(urban, veg, water))
Map$addLayer(fractions, {}, 'unmixed');
```
</div>

<center>
![Figure 12. Landsat 5 imagery unmixed to urban (red), vegetation (green) and water (blue) fractions. San Francisco bay area, California, USA.](F:/rgeebook/images/chapter_05/figure_12.png){width=670px}
</p>



<div style="text-align: justify">
## Texture {-}

Earth Engine has several special methods for estimating spatial texture. When the image is discrete valued (not floating point), you can use `image$entropy()` to compute the [entropy](http://en.wikipedia.org/wiki/Entropy_(information_theory)) in a neighborhood:

```{r, eval=FALSE}
## Load a high-resolution NAIP image.
image <- ee$Image('USDA/NAIP/DOQQ/m_3712213_sw_10_1_20140613')

## Zoom to San Francisco, display.
Map$setCenter(-122.466123, 37.769833, 17)
Map$addLayer(image, {max: 255}, 'image')

## Get the NIR band.
nir <- image.select('N')

## Define a neighborhood with a kernel.
square <- ee$Kernel$square(radius = 4)

## Compute entropy and display.
entropy <- nir.entropy(square)
Map$addLayer(entropy,
             list(min = 1, max = 5, palette = c('0000CC', 'CC0000') ),
             'entropy')
```

Note that the NIR band is scaled to 8-bits prior to calling `entropy()` since the entropy computation takes discrete valued inputs. The non-zero elements in the kernel specify the neighborhood.

Another way to measure texture is with a gray-level co-occurrence matrix (GLCM). Using the image and kernel from the previous example, compute the GLCM-based contrast as follows:

```{r, eval=FALSE}
## Compute the gray-level co-occurrence matrix (GLCM), get contrast.
glcm <- nir$glcmTexture(size = 4)
contrast <- glcm$select('N_contrast')
Map$addLayer(contrast,
             list(min = 0, max = 1500, palette = c('0000CC', 'CC0000')),
             'contrast')
```

Many measures of texture are output by `image$glcm()`. For a complete reference on the outputs, see [Haralick et al. (1973)](https://ieeexplore.ieee.org/document/4309314) and [Conners et al. (1984)](https://www.sciencedirect.com/science/article/abs/pii/0734189X8490197X).

Local measures of spatial association such as Geary’s C (Anselin 1995) can be computed in Earth Engine using `image$neighborhoodToBands()`. Using the image from the previous example:

```{r, eval=FALSE}
## Create a list of weights for a 9x9 kernel.
row <- c(1, 1, 1, 1, 1, 1, 1, 1, 1)
## The center of the kernel is zero.
centerRow = c(1, 1, 1, 1, 0, 1, 1, 1, 1)
## Assemble a list of lists: the 9x9 kernel weights as a 2-D matrix.
rows <- c(row, row, row, row, centerRow, row, row, row, row)
## Create the kernel from the weights.
## Non-zero weights represent the spatial neighborhood.
kernel <- ee$Kernel$fixed(9, 9, rows, -4, -4, false)

## Convert the neighborhood into multiple bands.
neighs <- nir$neighborhoodToBands(kernel)

## Compute local Geary's C, a measure of spatial association.
gearys <- nir$subtract(neighs)$pow(2)$reduce(ee$Reducer$sum())
             $divide(Math$pow(9, 2))
Map$addLayer(gearys,
             list(min = 20, max = 2500, palette = c('0000CC', 'CC0000')),
             "Geary's C")
```

For an example of using neighborhood standard deviation to compute image texture, see the [Statistics of Image Neighborhoods page]().

## Object-based methods {-}

Image objects are sets of connected pixels having the same integer value. Categorical, binned, and boolean image data are suitable for object analysis.

Earth Engine offers methods for labeling each object with a unique ID, counting the number of pixels composing objects, and computing statistics for values of pixels that intersect objects.

- `connectedComponents()`: label each object with a unique identifier.
- `connectedPixelCount()`: compute the number of pixels in each object.
- `reduceConnectedComponents()`: compute a statistic for pixels in each object.

**Caution**: results of object-based methods depend on scale, which is determined by:

- the requested scale of an output (e.g., `Export.image.toAsset()` or `Export.image.toDrive()`).
- functions that require a scale of analysis (e.g., `reduceRegions()` or `reduceToVectors()`).
- Map zoom level.

Take special note of scale determined by Map zoom level. Results of object-based methods will vary when viewing or inspecting image layers in the Map, as each pyramid layer has a different scale. To force a desired scale of analysis in Map exploration, use `reproject()`. However, it is strongly recommended that you **NOT** use `reproject()` because the entire area visible in the Map will be requested at the set scale and projection. At large extents this can cause too much data to be requested, often triggering errors. Within the image pyramid-based architecture of Earth Engine, scale and projection need only be set for operations that provide scale and crs as parameters. See [Scale of Analysis]() and [Reprojecting]() for more information.


### Thermal hotspots {-}

The following sections provide examples of object-based methods applied to Landsat 8 surface temperature with each section building on the former. Run the next snippet to generate the base image: thermal hotspots (> 303 degrees Kelvin) for a small region of San Francisco.

```{r, eval=FALSE}
## Make an area of interest geometry centered on San Francisco.
point <- ee.Geometry.Point(-122.1899, 37.5010);
aoi <- point.buffer(10000);

## Import a Landsat 8 image, subset the thermal band, and clip to the
## area of interest.
kelvin = ee.Image('LANDSAT/LC08/C01/T1_TOA/LC08_044034_20140318')
  .select(['B10'], ['kelvin'])
  .clip(aoi)

## Display the thermal band.
Map$centerObject(point, 13);
Map.$addLayer(kelvin, list(min = 288, max = 305), 'Kelvin')

## Threshold the thermal band to set hot pixels as value 1, mask all else.
hotspots <- kelvin.gt(303)
  .selfMask()
  .rename('hotspots')

## Display the thermal hotspots on the Map.
Map$addLayer(hotspots, list(palette = 'FF0000'), 'Hotspots')
```
<center>
![Figure 13. Temperature for a region of San Francisco. Pixels with temperature greater than 303 degrees Kelvin are distinguished by the color red (thermal hotspots).](F:/rgeebook/images/chapter_05/figure_13.png){width=670px}
</p>


### Label objects {-}

Labeling objects is often the first step in object analysis. Here, the `connectedComponents()` function is used to identify image objects and assign a unique ID to each; all pixels belonging to an object are assigned the same integer ID value. The result is a copy of the input image with an additional "labels" band associating pixels with an object ID value based on connectivity of pixels in the first band of the image.

```{r, eval=FALSE}
## Uniquely label the hotspot image objects.
objectId <- hotspots$connectedComponents(list(
  connectedness = ee.Kernel.plus(1),
  maxSize = 128)
  )

## Display the uniquely ID'ed objects to the Map.
Map$addLayer(objectId$randomVisualizer(), null, 'Objects')
```

Note that the maximum patch size is set to 128 pixels; objects composed of more pixels are masked. The connectivity is specified by an `ee$Kernel$plus(1)` kernel, which defines four-neighbor connectivity; use `ee$Kernel$square(1)` for eight-neighbor.
<center>
![Figure 14. Thermal hotspot objects labeled and styled by a unique ID.](F:/rgeebook/images/chapter_05/figure_14.png){width=670px}

</p>


### Object size {-}

#### Number of pixels {-}
Calculate the number of pixels composing objects using the `connectedPixelCount()` image method. Knowing the number of pixels in an object can be helpful for masking objects by size and calculating object area. The following snippet applies `connectedPixelCount()` to the "labels" band of the `objectId` image defined in the previous section.

```{r, eval=FALSE}
## Compute the number of pixels in each object defined by the "labels" band.
objectSize <- objectId$select('labels')$
  connectedPixelCount(list(
     maxSize = 128, eightConnected = false)
     )

## Display object pixel count to the Map.
Map$addLayer(objectSize, null, 'Object n pixels');
```

`connectedPixelCount()` returns a copy of the input image where each pixel of each band contains the number of connected neighbors according to either the four- or eight-neighbor connectivity rule determined by a boolean argument passed to the `eightConnected` parameter. Note that connectivity is determined independently for each band of the input image. In this example, a single-band image (`objectId`) representing object ID was provided as input, so a single-band image was returned with a "labels" band (present as such in the input image), but now the values represent the number of pixels composing objects; every pixel of each object will have the same pixel count value.
<center>
![Figure 15. Thermal hotspot objects labeled and styled by a unique ID.](F:/rgeebook/images/chapter_05/figure_15.png){width=670px}

</p>


#### Area {-}
Calculate object area by multiplying the area of a single pixel by the number of pixels composing an object (determined by `connectedPixelCount()`). Pixel area is provided by an image generated from `ee$Image$pixelArea()`.

```{r, eval=FALSE}
## Get a pixel area image.
pixelArea <- ee$Image$pixelArea()

## Multiply pixel area by the number of pixels in an object to calculate
## the object area. The result is an image where each pixel
## of an object relates the area of the object in m^2.
objectArea <- objectSize$multiply(pixelArea)

## Display object area to the Map.
Map$addLayer(objectArea,
             list(min = 0, max = 30000, palette = c('0000FF', 'FF00FF')),
             'Object area m^2')
```

The result is an image where each pixel of an object relates the area of the object in square meters. In this example, the `objectSize` image contains a single band, if it were multi-band, the multiplication operation would be applied to each band of the image.

### Filter objects by size {-}
Object size can be used as a mask condition to focus your analysis on objects of a certain size (e.g., mask out objects that are too small). Here the `objectArea` image calculated in the previous step is used as a mask to remove objects whose area are less than one hectare.

```{r, eval=FALSE}
## Threshold the `objectArea` image to define a mask that will mask out
## objects below a given size (1 hectare in this case).
areaMask <- objectArea$gte(10000)

## Update the mask of the `objectId` layer defined previously using the
## minimum area mask just defined.
objectId <- objectId$updateMask(areaMask)
Map$addLayer(objectId, null, 'Large hotspots')
```

The result is a copy of the `objectId` image where objects less than one hectare are masked out.

Figure 16a. Thermal hotspot objects labeled and styled by unique ID.             |  Figure 16b. Thermal hotspot objects filtered by minimum area (1 hectare).
:-------------------------:|:-------------------------:
![](F:/rgeebook/images/chapter_05/figure_16a.png){width=300px}  |  ![](F:/rgeebook/images/chapter_05/figure_16b.png){width=300px}

### Zonal statistics {-}

The `reduceConnectedComponents()` method applies a reducer to the pixels composing unique objects. The following snippet uses it to calculate the mean temperature of hotspot objects. `reduceConnectedComponents()` requires an input image with a band (or bands) to be reduced and a band that defines object labels. Here, the `objectID` "labels" image band is added to the `kelvin` temperature image to construct a suitable input image.

```{r, eval=FALSE}
## Make a suitable image for `reduceConnectedComponents()` by adding a label
## band to the `kelvin` temperature image.
kelvin <- kelvin$addBands(objectId$select('labels'))

## Calculate the mean temperature per object defined by the previously added
## "labels" band.
patchTemp <- kelvin$reduceConnectedComponents(list(
  reducer = ee$Reducer$mean(),
  labelBand = 'labels')
)

## Display object mean temperature to the Map.
Map$addLayer(
  patchTemp,list(
    min = 303, max = 304, palette = c('yellow', 'red')),
  'Mean temperature'
)
```

The result is a copy of the input image without the band used to define objects, where pixel values represent the result of the reduction per object, per band.
<center>
![Figure 17. Thermal hotspot object pixels summarized and styled by mean temperature.](F:/rgeebook/images/chapter_05/figure_17.png){width=670px}

</p>


<div style="text-align: justify">
- **Note**: `reduceToVectors()` provides similar functionality, except that the result is an `ee$FeatureCollection`, where each feature of the collection represents an object and the reduction of the pixels in each objects is expressed as a feature property for each band in the input image. `reduceToVectors()` is resource intensive, so use `reduceConnectedComponents()` whenever possible. See Raster to Vector Conversion for more information.
</div>

## Cumulative Cost Mapping {-}

Use `image$cumulativeCost()` to compute a cost map where every pixel contains the total cost of the lowest cost path to the nearest source location. This process is useful in a variety of contexts such as habitat analysis ([Adriaensen et al. 2003](http://www.sciencedirect.com/science/article/pii/S0169204602002426)), watershed delineation ([Melles et al. 2011](https://www.sciencedirect.com/science/article/pii/S1878029611001691)) and image segmentation ([Falcao et al. 2004](http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1261076)). Call the cumulative cost function on an image in which each pixel represents the cost per meter to traverse it. Paths are computed through any of a pixel's eight neighbors. Required inputs include a `source` image, in which each non-zero pixel represents a potential source (or start of a path), and a `maxDistance` (in meters) over which to compute paths. The algorithm finds the cumulative cost of all paths less than *maxPixels* = `maxDistance`/*scale* in length, where scale is the pixel resolution, or [scale of analysis in Earth Engine]().

The following example demonstrates computing least-cost paths across a land cover image:
```{r, eval=FALSE}
## A rectangle representing Bangui, Central African Republic.
geometry <- ee$Geometry$Rectangle(c(18.5229, 4.3491, 18.5833, 4.4066))

## Create a source image where the geometry is 1, everything else is 0.
sources <- ee$Image()$toByte()$paint(geometry, 1)

## Mask the sources image with itself.
sources <- sources$selfMask()

## The cost data is generated from classes in ESA/GLOBCOVER.
cover <- ee$Image('ESA/GLOBCOVER_L4_200901_200912_V2_3')$select(0)

# Classes 60, 80, 110, 140 have cost 1.
## Classes 40, 90, 120, 130, 170 have cost 2.
## Classes 50, 70, 150, 160 have cost 3.
beforeRemap <- c(60, 80, 110, 140,
                40, 90, 120, 130, 170,
                50, 70, 150, 160)
afterRemap <- c(1, 1, 1, 1,
                2, 2, 2, 2, 2,
                3, 3, 3, 3)
cost <- cover$remap(beforeRemap, afterRemap, 0)

## Compute the cumulative cost to traverse the land cover.
cumulativeCost <- cost$cumulativeCost(list(
  source = sources,
  maxDistance = 80 * 1000)  ## 80 kilometers
  )

## Display the results
Map$setCenter(18.71, 4.2, 9)
Map$addLayer(cover, {}, 'Globcover')
Map$addLayer(cumulativeCost, list(min = 0, max = 5e4), 'accumulated cost')
Map$addLayer(geometry, list(color = 'FF0000'), 'source geometry')
```

The result should look something like Figure 18, in which each output pixel represents the accumulated cost to the nearest source. Note that discontinuities can appear in places where the least cost path to the nearest source exceeds *maxPixels* in length.
<center>
![Figure 18. The cumulative cost to the source pixels, where cost is determined by the land cover categories. Low costs are black, higher costs are white.](F:/rgeebook/images/chapter_05/figure_18.png){width=660px}

</p>

## Registering Images {-}

The Earth Engine image registration algorithm is designed to be a final, post-ortho, fine-grained step in aligning images. It is assumed that the images to be registered have already gone through initial alignment stages, so they are already within a few degrees of rotation of one another, and differ by only small translations. The registration uses a “rubber-sheet” technique, allowing local image warping to correct for orthorectification errors and other artifacts from earlier processing. The underlying alignment technique is image correlation, so the bands for the input and reference images must be visually similar in order for the algorithm to compute an accurate alignment.

### Image displacement {-}

There are two steps to registering an image: Determining the displacement image using `displacement()`, and then applying it with `displace()`. The required inputs are the pair of images to register, and a maximum displacement parameter (`maxOffset`).

The `displacement()` algorithm takes a reference image, a maximum displacement parameter (`maxOffset`), and two optional parameters that modify the algorithm behaviour. The output is a displacement image with bands dx and dy which give the X and Y components (in meters) of the displacement vector at each pixel.

All bands of the calling and reference images are used for matching during registration, so the number of bands must be exactly equal. The input bands must be visually similar for registration to succeed. If that is not the case, it may be possible to pre-process them (e.g. smoothing, edge detection) to make them appear more similar. The registration computations are performed using a multiscale, coarse-to-fine process, with (multiscale) working projections that depend on three of the projections supplied to the algorithm:

1. the default projection of the calling image (Pc)
2. the default projection of the reference image (Pr)
3. the output projection (Po)

The highest resolution working projection (Pw will be in the CRS of Pr, at a scale determined by the coarsest resolution of these 3 projections, to minimize computation. The results from Pr are then resampled to be in the projection specified by the input ‘projection’ parameter.

The output is a displacement image with the following bands:

`dx`
- For a given reference image pixel location, this band contains the distance in the X direction that must be travelled to arrive at the matching location in the calling image. Units are in geodesic meters.

`dy`
- For a given reference image pixel location, this band contains the distance in the Y direction that must be travelled to arrive at the matching location in the calling image. Units are in geodesic meters.

`confidence`
- This is a per-pixel estimate of displacement confidence (where 0 is low confidence and 1 is high confidence) based on the correlation scores in regions where valid matches were found. In regions where no matches were found, confidence is estimated from nearby correlations using a Gaussian kernel to provide higher weight to nearby correlations.

The following example computes the magnitude and angle of displacement between two high-resolution [Terra Bella]() images:

```{r, eval=FALSE}
## Load the two images to be registered.
image1 <- ee$Image('SKYSAT/GEN-A/PUBLIC/ORTHO/MULTISPECTRAL/s01_20150502T082736Z')
image2 <- ee$Image('SKYSAT/GEN-A/PUBLIC/ORTHO/MULTISPECTRAL/s01_20150305T081019Z')

## Use bicubic resampling during registration.
image1Orig <- image1$resample('bicubic')
image2Orig <- image2$resample('bicubic')

## Choose to register using only the 'R' band.
image1RedBand <- image1Orig$select('R')
image2RedBand <- image2Orig$select('R')

## Determine the displacement by matching only the 'R' bands.
displacement <- image2RedBand.displacement(list(
  referenceImage = image1RedBand,
  maxOffset = 50.0,
  patchWidth = 100.0)
)

## Compute image offset and direction.
offset <- displacement$select('dx')$hypot(displacement$select('dy'))
angle <- displacement$select('dx')$atan2(displacement$select('dy'))

## Display offset distance and angle.
Map$addLayer(offset, list(min = 0, max = 20), 'offset')
Map$addLayer(angle, list(min = -Math.PI, max = Math.PI), 'angle')
Map$setCenter(37.44,0.58, 15)
```

### Warping an image {-}

There are two ways to warp an image to match another image: `displace()` or `register()`. The `displace()` algorithm takes a displacement image having `dx` and `dy` bands as the first two bands, and warps the image accordingly. The output image will be the result of warping the bands of the input image by the offsets present in the displacement image. Using the displacements computed in the previous example:

```{r, eval=FALSE}
## Use the computed displacement to register all original bands.
registered <- image2Orig$displace(displacement)

## Show the results of co-registering the images.
visParams <- list(bands = c('R', 'G', 'B'), max = 4000)
Map$addLayer(image1Orig, visParams, 'Reference')
Map$addLayer(image2Orig, visParams, 'Before Registration')
Map$addLayer(registered, visParams, 'After Registration')
```

If you don't need the displacement bands, Earth Engine provides the `register()` method, which is a shortcut for calling `displacement()` followed by `displace()`. For example:

```{r, eval=FALSE}
alsoRegistered <- image2Orig$register(list(
  referenceImage = image1Orig,
  maxOffset = 50.0,
  patchWidth = 100.0)
  )
Map.addLayer(alsoRegistered, visParams, 'Also Registered')
```

In this example, the results of `register()` differ from the results of `displace()`. This is because a different set of bands was used in the two approaches: `register()` always uses all bands of the input images, while the `displacement()` example used only the red band before feeding the result to `displace()`. Note that when multiple bands are used, if band variances are very different this could over-weight the high-variance bands, since the bands are jointly normalized when their spatial correlation scores are combined. This illustrates the importance of selecting band(s) that are visually the most similar when registering. As in the previous example, use `displacement()` and `displace()` for control over which bands are used to compute displacement.

</div>
# ImageCollection

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Geometry

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Feature & FeatureCollection

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Reducer

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Join

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Array

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Chart

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

</div>

