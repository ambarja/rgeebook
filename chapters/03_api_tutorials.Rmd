# (PART) API Tutorials {-}

```{r, include = FALSE}
source("common.R")
```
# Overview

<<<<<<< Updated upstream
To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

=======
To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapt 
 
## Tutorials
>>>>>>> Stashed changes

## Tutorial 

These tutorials are an introduction to using the Earth Engine R API for advanced geospatial analysis. The tutorials assume no programming background, although they do assume a willingness to learn some R programming. Use the links below to get started on the tutorials or use the menus on the left to jump to a section of interest.


# Introduction to R for Earth Engine

This tutorial covers just enough JavaScript to get you started writing Earth Engine scripts. For more thorough JavaScript tutorials, see these Mozilla developer resources. For an introduction to programming, with examples in JavaScript, see Eloquent JavaScript. For suggestions on JavaScript coding style, see the Google JavaScript Style Guide. In this tutorial, you're going to write JavaScript in the Earth Engine Code Editor. Before getting started, use the Code Editor guide to get familiar with the Code Editor environment.

## Hello Word {-}

Time to write your first code in R for Earth Engine! In your Rstudio,  copy the following into the Code Editor:

```{R, eval=FALSE}
print('Hello World!')
```

Click Run and observe that 'Hello world!' is printed to the Console tab. The line above is R statement. Earth Engine programs are made up of a set of statements like this one. You can prevent code from running without deleting it by commenting it. One of the ways to comment out code is by putting two forward numerals `##` before the code that you don't want to run. For example:

```{R, eval=FALSE}
## print('Hello World!')
```

It's good practice to put lots of comments in your code, to describe what you're trying to do. It's also good to delete commented code that doesn't do anything anymore. Both these practices will improve code readability.

## Basic JavaScript data type {-}

### Strings {-}

Using variables to store objects and primitives helps code readability. For example, a variable that stores a string object is defined by single ' or double " quotes (but don't mix them), with single quotes preferred. Make a new string and store it in a variable called greetString:

```{R, eval=FALSE}
## Use single (or double) quotes to make a string.
var greetString = 'Ahoy there!'
## Use parentheses to pass arguments to functions.
print(greetString)
```

### Numbers {-}

Note that variables are defined with the keyword `var`. Variables can also store numbers:

```{R, eval=FALSE}
## Store a number in a variable.
var number = 42
print('The answer is:', number)
```

In this example, observe that when `print()` is given two arguments separated by commas, each argument is printed on a different line.

### List {-}

Define lists with square brackets `[]`. A list of numbers, for example:

```{R, eval=FALSE}
## Use square brackets [] to make a list.
var listOfNumbers = [0, 1, 1, 2, 3, 5]
print('List of numbers:', listOfNumbers)
```

Lists can also store strings or other objects. For example:

```{R, eval=FALSE}
## Make a list of strings.
var listOfStrings = ['a', 'b', 'c', 'd']
print('List of strings:', listOfStrings)
```

### Objects {-}

Objects in R are dictionaries of `key: value` pairs. Make an object (or dictionary) using curly brackets {}, for example:

```{R, eval=FALSE}
## Use curly brackets {} to make a dictionary of key:value pairs.
var object = {
  foo: 'bar',
  baz: 13,
  stuff: ['this', 'that', 'the other thing']
}
print('Dictionary:', object)
## Access dictionary items using square brackets.
print('Print foo:', object['foo'])
## Access dictionary items using dot notation.
print('Print stuff:', object.stuff)
```

Note that you can get a value from a dictionary by supplying the key. This example shows you how to do that for R objects. Later you'll learn how to do it for dictionaries that are on the Earth Engine server.

### Functions {-}

Functions are another way to improve code readability and reusability by grouping sets of operations. Define a function with the `function` keyword. Function names start with a letter and have a pair of parentheses at the end. Functions often take parameters which tell the function what to do. These parameters go inside the parentheses `()`. The set of statements making up the function go inside curly brackets. The `return` keyword indicates what the function output is. There are several ways to declare a function, but here we'll use something like this:

```{R, eval=FALSE}
var myFunction = function(parameter1, parameter2, parameter3) {
  statement;
  statement;
  statement;
  return statement;
}
```

Let's consider the lines one by one. The first line creates a new function and assigns it to the variable myFunction. This variable could have been named anything. It defines how to call the function later. The terms in the parentheses after the function name (i.e. parameter1, parameter2, parameter3) are the parameter names and could have been named anything as well, though it's good practice to give them unique names that are different from the code outside the function. Whatever you name them, these are the names that function will use to refer to the values that are passed into the function when it is called. The value of a parameter once it's been passed into a function is called an argument. Although functions can use variables declared outside the function (global variables), function arguments are not visible outside the function. Functions can take as many parameters as you need, even zero. Here's a simple example of a function that just returns its argument:

```{R, eval=FALSE}
## The reflect function takes a single parameter: element.
var reflect = function(element) {
## Return the argument.
  return element
}
print('A good day to you!', reflect('Back at you!'))
```

This is an example of a user-defined function. There are also lots of built-in Earth Engine functions. Explore the Code Editor Docs tab to learn about these built-in functions. Here's a very simple example of an Earth Engine function:

```{R, eval=FALSE}
var aString = ee.Algorithms.String(42)
```

## Earth Engine Objects {-}

Now that you're comfortable with R, learn how to put  objects in R and primitives into Earth Engine containers for sending to the server and processing at Google.

### Strings {-}

For example, define a string, then put it into the `ee.String()` container to be sent to Earth Engine:

```{R, eval=FALSE}
## Define a string, then put it into an EE container.
var aString = 'To the cloud!'
var eeString = ee.String(aString)
print('Where to?', eeString)
```

Think of `ee.Thing` as a container for a thing that exists on the server. In this example, the string is defined first, then put into the container. You can also define the container and its contents all at once. For example:

```{R, eval=FALSE}
## Define a string that exists on the server.
var serverString = ee.String('This is on the server.')
print('String on the server:', serverString)
```

Although the first argument to `print()` is just a string on the client, the second argument is actually sent to the server to be evaluated, then sent back.

### Numbers {-}

Use `ee.Number()` to create number objects on the server. For example, use the `Math.E` R method to create a constant value on the server:

```{R, eval=FALSE}
## Define a number that exists on the server.
var serverNumber = ee.Number(Math.E)
print('e=', serverNumber)
```

The `ee.String()` and `ee.Number()` methods are constructors. A constructor takes its argument (and possibly other parameters), puts it in a container, and returns the container and its contents as an Earth Engine object that you can manipulate in your code. Any constructor starting with `ee` returns an Earth Engine object.

### Methods on Earth Engine objects {-}

Note that once you've created an Earth Engine object, you have to use Earth Engine methods to process it. In this example, you can't use R's `Math.log()` to process that Earth Engine object. You have to use the equivalent method defined for an `ee.Number`:

```{R, eval=FALSE}
## Use a built-in function to perform an operation on the number.
var logE = serverNumber.log()
print('log(e)=', logE)
```

In this example, `log()` is a method for a `ee.Number` object. (Use the Docs tab at the left side of the code editor to see a list of all the methods for every Earth Engine object type, for example ee.Number > log()). Note that the methods of Earth Engine objects return other Earth Engine objects.

### List {-}

To make a JavaScript list into an `ee.List` object on the server, you can put a JavaScript literal into a container as with numbers and strings. Earth Engine also provides server-side convenience methods for making sequences of numbers. For example:

```{R, eval=FALSE}
## Make a sequence the hard way.
var eeList = ee.List([1, 2, 3, 4, 5])
## Make a sequence the easy way!
var sequence = ee.List.sequence(1, 5)
print('Sequence:', sequence)
```

Since the `ee.List` objects only exist on the server, use Earth Engine provided functions to interact with them. For example, to get something out of the list, use the `get()` method of the `ee.List` object:

```{R, eval=FALSE}
## Use a method on an ee.List to extract a value.
var value = sequence.get(2)
print('Value at index 2:', value)
```

### Casting {-}

Sometimes, Earth Engine doesn't know the type of an object that gets returned from a method. You, as the programmer, know that the `value` variable in the previous example is a number object. But if you try to use the `add()` method of an `ee.Number`, you'll get an error like:


This is common with the `get()` function, which could return all sorts of Earth Engine objects. To correct it, use the `ee.Number` constructor to cast the result:

```{R, eval=FALSE}
## Cast the return value of get() to a number.
print('No error:', ee.Number(value).add(3));
```

### Dictionaries {-}

You can construct an Earth Engine `Dictionary` from a R object, as with strings, numbers and lists. At construction time, you can use R functionality to initialize the Earth Engine object. In this case an `ee.Dictionary` is constructed directly from a R literal object:

```{R, eval=FALSE}
## Make a Dictionary on the server.
var dictionary = ee.Dictionary({
  e: Math.E,
  pi: Math.PI,
  phi: (1 + Math.sqrt(5)) / 2
})

## Get some values from the dictionary.
print('Euler:', dictionary.get('e'))
print('Pi:', dictionary.get('pi'))
print('Golden ratio:', dictionary.get('phi'))

## Get all the keys:
print('Keys: ', dictionary.keys())
```

In this example, observe that once you have an `ee.Dictionary`, you must use methods on the `ee.Dictionary` to get values (unlike the JavaScript dictionary in the previous lesson). Specifically, `get(key)` returns the value associated with `key`. Since the type of object returned by `get()` could be be anything, if you're going to do anything to the object other then print it, you need to cast it to the right type. Also note that the `keys()` method returns an `ee.List`.

### Dates {-}

Date objects are the way Earth Engine represents time. As in the previous examples, it is important to distinguish between a R Date object and an Earth Engine `ee.Date` object. Construct an `ee.Date` from a string, from a R `Date`, or using static methods provided by the `ee.Date` class. (See the Date section in the Docs tab for details). This example illustrates the construction of dates from strings or a JavaScript date representing milliseconds since midnight on January 1, 1970:

```{R, eval=FALSE}
## Define a date in Earth Engine.
var date = ee.Date('2015-12-31')
print('Date:', date)

## Get the current time using the R Date.now() method.
var now = Date.now()
print('Milliseconds since January 1, 1970', now)

## Initialize an ee.Date object.
var eeNow = ee.Date(now)
print('Now:', eeNow)
```

Dates are useful for filtering collections, specifically as arguments to the `filterDate()` method. See this section of the Get Started page for more information about sorting collections.

### Digression: passing parameters by name {-}

Arguments to Earth Engine methods can be passed in order, for example to create an `ee.Date` from year, month and day, you can pass parameters of the `fromYMD()` static method in the order year, month, day:

```{R, eval=FALSE}
var aDate = ee.Date.fromYMD(2017, 1, 13)
print('aDate:', aDate)
```

Alternatively, you can pass the parameters by name, in any order. While it might be more code, it can improve readability and reusability. To pass parameters by name, pass in a R object in which the keys of the object are the names of the method parameters and the values are the arguments to the method. For example:

```{R, eval=FALSE}
var theDate = ee.Date.fromYMD({
  day: 13,
  month: 1,
  year: 2017
})
print('theDate:', theDate)
```

Note that the names of the object properties (the keys) match the names specified in the `ee.Date.fromYMD()` docs. Also note that the object that is passed as an argument can be saved in a variable for reuse, as illustrated by the R object example.

You now have enough of an introduction to R to start using Earth Engine! See the Client vs. Server page for a more detailed explanation of R vs. Earth Engine objects.

In the next section, learn more about Functional programming concepts to effectively use for-loops, if/else conditions and iterations in Earth Engine.

## Functional Programming Concepts {-}

### Introduction to functional programming {-}

Earth Engine uses a parallel processing system to carry out computation across a large number of machines. To enable such processing, Earth Engine takes advantage of standard techniques commonly used by functional languages, such as referential transparency and lazy evaluation, for significant optimization and efficiency gains.

The main concept that sets functional programming apart from procedural programming is *the absence of side effects*. What it means is that the functions that you write doesn’t rely on or update data that is outside of the function. As you will see in the examples below, it is possible to re-structure your problem so that it can be solved using functions without side-effects - which are much better suited to be executed in parallel.

#### For Loops {-}

The use of for-loops is discouraged in Earth Engine. The same results can be achieved using a `map()` operation where you specify a function that can be independently applied to each element. This allows the system to distribute the processing to different machines.

The example below illustrates how you would take a list of numbers and create another list with the squares of each number using `map()`:

```{R, eval=FALSE}
## This generates a list of numbers from 1 to 10.
var myList = ee.List.sequence(1, 10)

## The map() operation takes a function that works on each element independently
## and returns a value. You define a function that can be applied to the input.
var computeSquares = function(number) {
  ## We define the operation using the EE API.
  return ee.Number(number).pow(2)
}

## Apply your function to each item in the list by using the map() function.
var squares = myList.map(computeSquares)
print(squares)  ## [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### If/Else Conditions {-}

Another common problem faced by new users who are used to procedural programming paradigm is the proper use of if/else conditional operators in Earth Engine. While, the API does provide a `ee.Algorithms.If()` algorithm, the use of it is strongly discouraged in favor of a more functional approach using `map()` and filters. Earth Engine uses deferred execution, which means that the evaluation of an expression is delayed until its realized value is actually required. In some cases, this type of execution model will evaluate both the true and false alternatives of an `ee.Algorithms.If()` statement. This can lead to extra computation and memory usage, depending on the expressions and the resources required to execute them.

Say you want to solve a variant of the above example, where the task is to compute squares of only odd numbers. A functional approach to solving this without if/else conditions, is demonstrated below:

```{R, eval=FALSE}
## The following function determines if a number is even or odd.  The mod(2)
## function returns 0 if the number is even and 1 if it is odd (the remainder
## after dividing by 2).  The input is multipled by this remainder so even
## numbers get set to 0 and odd numbers are left unchanged.
var getOddNumbers = function(number) {
  number = ee.Number(number)   ## Cast the input to a Number so we can use mod.
  var remainder = number.mod(2)
  return number.multiply(remainder)
}

var newList = myList.map(getOddNumbers)

## Remove the 0 values.
var oddNumbers = newList.removeAll([0])

var squares = oddNumbers.map(computeSquares)
print(squares);  ## [1, 9, 25, 49, 81]
```

This paradigm is especially applicable when working with collections. If you wanted to apply a different algorithm to the collection based on some conditions, the preferred way is to first filter the collection based on the condition, and then `map()` a different function to each of the subsets. This allows the system to parallelize the operation. For example:

```{R, eval=FALSE}
var collection = ee.ImageCollection('LANDSAT/LC08/C01/T1_TOA')

## Divide the collection into 2 subsets and apply a different algorithm on them.
var subset1 = collection.filter(ee.Filter.lt('SUN_ELEVATION', 40))
var subset2 = collection.filter(ee.Filter.gte('SUN_ELEVATION', 40))

var processed1 = subset1.map(function(image) {
  return image.multiply(2);
})
var processed2 = subset2;

## Merge the collections to get a single collection.
var final = processed1.merge(processed2)
print('Original collection size', collection.size())
print('Processed collection size', final.size())
```

#### Cumulative Iteration {-}

You may need to do sequential operation, where the result of each iteration is used by the subsequent iteration. Earth Engine provides a `iterate()` method for such tasks. Remember that `iterate()` is executed in a sequential manner and hence will be slow for large operations. Use it only when you are not able to use `map()` and filters to achieve the desired output.

A good demonstration of `iterate()` is for creation of Fibonacci number sequence. Here, each number in the series is the sum of previous 2 numbers. The `iterate()` function takes 2 arguments, a function (algorithm) and a starting value. The function itself gets passed on 2 values, the current value in the iteration, and the result of the previous iteration. The following example demonstrates how to implement a fibonacci sequence in Earth Engine.

```{R, eval=FALSE}
var algorithm = function(current, previous) {
  previous = ee$List(previous)
  var n1 = ee$Number(previous.get(-1))
  var n2 = ee$Number(previous.get(-2))
  return previous.add(n1.add(n2))
}

## Compute 10 iterations.
var numIteration = ee.List.repeat(1, 10)
var start = [0, 1]
var sequence = numIteration.iterate(algorithm, start)
print(sequence)  ## [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
```

Now that you have a good understanding of javascript concepts, you can see the API Tutorial for an introduction to the geospatial functionality of the Earth Engine API.


# The Earth Engine API {-}

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

## Visualizing Images and Image Bands {-}

Now that you're ready to begin writing in R of the Earth Engine , start by copying the following code into the Code Editor:

```{R, eval=FALSE}
## Instantiate an image with the Image constructor.
image = ee$Image('CGIAR/SRTM90_V4')

## Zoom to a location.
Map$setCenter(-112.8598, 36.2841, 9) ## Center on the Grand Canyon.

## Display the image on the map.
Map$addLayer(image)
```

Click the Run button at the top of the Code Editor and observe that a very gray image appears on the map. Don't worry, you'll make it look better soon.

## Image Constructor {-}

The first new thing in this example is the image constructor `ee.Image()`. The argument provided to the constructor is the string ID of an image in the Earth Engine data catalog. (See the Docs tab, at the left of the Code Editor, to see a full list of possible arguments to the image constructor. The Docs tab represents the most up to date information about what Earth Engine can do.)

To discover an image ID, search in the Earth Engine data catalog using the search tool at the top of the Code Editor. For example, type 'elevation' into the search field and note that a list of rasters is returned. Click the 'SRTM Digital Elevation Data Version 4' entry to see more information about that dataset. On the right side of the dataset description is an Image ID field. Observe that the image ID in the example is copied from the image ID shown in the dataset description.

An alternative to copying and pasting image IDs is to use the Import button on the dataset description or the import link at the right side of the search results. If you click the import link or button, a variable is automatically created in a special section, named 'Imports', at the top of your script. You can rename the variable by clicking on its name in the imports section.

## Configuring the Map {-}

The second new part of this example is the `Map.setCenter()` call. This method on the `Map` object, which represents the Map display in the Code Editor, centers the map at the given longitude, latitude (in decimal degrees) and zoom level where 1 is zoomed out so that the map shows the entire Earth's surface. Larger numbers zoom in from there. Discover all the methods on the `Map` object by checking the Map section in the Docs tab on the left side of the Code Editor.

## Adding a layer to the Map {-}

The last line in the example says: use the `Map` object's `addLayer()` method to add an image to the map display in the Code Editor.

Congratulations! You've created your first Earth Engine script. In the next section, you'll learn how to make that image look a little better.

## Digression: Images in Earth Engine {-}

Images in Earth Engine (see this page for more details) are made up of one or more bands. Each band in an image has its own name, pixel values, pixel resolution, and projection. As you'll soon discover, the SRTM image has one band: 'elevation'.

When you add an image to a map using `Map.addLayer()`, Earth Engine needs to determine how to map the values in the image band(s) to colors on the display. If a single-band image is added to a map, by default Earth Engine displays the band in grayscale, where the minimum value is assigned to black, and the maximum value is assigned to white. If you don't specify what the minimum and maximum should be, Earth Engine will use default values. For example, the image you just added to the map is displayed as a grayscale image stretched to the full range of the data, or signed 16-bit integer [-32768, 32767]. (`float` bands are stretched to [0, 1] and `byte` bands are stretched to [0, 255] by default).

You can discover the data type of the image by printing it and inspecting the image object in the **Console** tab. For example, paste the following after the previous code:

```{R, eval=FALSE}
print('SRTM image', image)
```

When you click run, note that an object appears in the console. To investigate the object properties, expand it by clicking on the zippy () to the left of the object or property. Expand the image object, the 'bands' property, the 'elevation' band at index '0' and the 'data_type' property of the 'elevation' band to discover that it is a `signed int16` data type.

## Customizing layer visualization {-}

To change the way the data are stretched, you can provide another parameter to the `Map.addLayer()` call. Specifically, the second parameter, `visParams`, lets you specify the minimum and maximum values to display. To discover what values to use, activate the Inspector tab and click around on the map to get an idea of the range of pixel values. Alternatively, use the Layer manager to interactively stretch the data, then observe the minimum and maximum corresponding to percentiles or standard deviation stretches. Suppose that through such experimentation, you determine that the data should be stretched to [0, 3000]. To display the image using this range, use:

```{R, eval=FALSE}
Map$addLayer(image, list(min = 0, max = 3000), 'custom visualization')
```

Note that the visParams parameter is an object, with properties specifying the min and the max. Note that the third parameter for `Map.addLayer()` is the name of the layer that is displayed in the Layer manager. The result should look something like Figure 1. Hover the mouse over the **Layers** box on the right to see the effect of renaming that layer.

<center>
![Figure 8. Elevation image as grayscale, stretched to (0, 3000)](C:/Users/USUARIO/OneDrive/Escritorio/rgeebook/rgeebook/images/chapter_09/image_01.png){width=670px}

<left>

To display a single band using a color palette, add a `palette` property to the `visParams` object:

```{R, eval=FALSE}
Map$addLayer(image, list(min = 0, max = 3000, palette = c('blue', 'green', 'red')), 
             'custom palette')
```

The result should look something like Figure .

<center>
![Figure 8. Elevation image as a color ramp from blue to red, stretched to (0, 3000).](C:/Users/USUARIO/OneDrive/Escritorio/rgeebook/rgeebook/images/chapter_09/image_02.png){width=670px}

<left>

## Digression: Palettes {-}

Palettes let you set the color scheme for single-band images. A palette is a comma delimited list of color strings which are linearly interpolated between the maximum and minimum values in the visualization parameters (or defaults according to the band type, as described previously). For example, pixels less than or equal to the minimum will be displayed with the first color in the list; pixels greater than or equal to the maximum will be displayed with the last color in the list. Intermediate colors are linearly stretched to intermediate pixel values.

The colors are defined using the web standard CSS color value scheme (see this external reference to learn more). Colors can be specified by name or as hexadecimal strings indicating the combination of red, green and blue. The lowest value in any of the three positions is 00 (representing the decimal number 0), while the highest is FF (representing the decimal number 255). The string '000000' represents the color black, 'FFFFFF' is white, 'FF0000' is red, '00FF00' is green, and '0000FF' is blue. See the Color palettes section for more detail. Other stretches are possible by using Styled Layer Descriptors, as described in this section.

Later in this tutorial, you'll learn how to display multi-band imagery. But first, visit the next page to learn about performing computations with images.


## Computations using Images {-}

Now that you know how to load and display an image, it's time to apply a computation to it. For example, you can compute the slope of terrain, by passing the SRTM elevation image to the `slope` method of the `ee.Terrain` package.

```{R, eval=FALSE}
## Load the SRTM image.
srtm = ee$Image('CGIAR/SRTM90_V4')

## Apply an algorithm to an image.
slope = ee$Terrain$slope(srtm)

## Display the result.
Map$setCenter(-112.8598, 36.2841, 9) ## Center on the Grand Canyon.
Map$addLayer(slope, list(min = 0, max = 60), 'slope')
```

Note that in the code `ee.Terrain.slope(srtm)`, the srtm image is provided as an argument to the slope algorithm. The result should look something like Figure 3.

<center>
![Figure 8. Slope image.](C:/Users/USUARIO/OneDrive/Escritorio/rgeebook/rgeebook/images/chapter_09/image_03.png){width=670px}

<left>

## Image math {-}

There are also methods in the `ee.Image` class that can be invoked on an image object. For example, suppose you'd like to do some math using image bands (sometimes called *band math* or *map algebra*). For example, you may be interested in trigonometric operations on an aspect image. To accomplish that, first convert an aspect image to radians, then call `sin()` on it. Reusing our `srtm` image.

```{R, eval=FALSE}
## Get the aspect (in degrees).
aspect = ee$Terrain$aspect(srtm)

## Convert to radians, compute the sin of the aspect.
sinImage = aspect$divide(180)$multiply(Math$PI)$sin()

## Display the result.
Map$addLayer(sinImage, list(min = -1, max = 1), 'sin')
```

The result should look something like Figure . It's worth taking a closer look at the `aspect$divide(180)$multiply(Math$PI)$sin()` code. By chaining multiple methods like this, the code says, 'divide the aspect by 180, multiply the result of that by π, and finally take the sin'. You can perform complex mathematical operations on images by combining methods in this manner. See the `Image` [docs](https://developers.google.com/earth-engine/apidocs/ee-image) for a complete list of mathematical operations, `add()`, `subtract()`, `multiply()`, etc.

<center>
![Figure 8. Slope image.](C:/Users/USUARIO/OneDrive/Escritorio/rgeebook/rgeebook/images/chapter_09/image_04.png){width=670px}

## Image statistics {-}

Another useful class of operations on images involves computing pixel statistics in image regions, or raster-vector overlays. To compute statistics in Earth Engine, use a reducer as represented by classes in the `ee.Reducer` [package](https://developers.google.com/earth-engine/guides/reducers_intro).For example, suppose you're interested in the mean of elevation in some region. You can define a region by drawing a polygon using the [geometry drawing tools](https://developers.google.com/earth-engine/guides/playground#geometry-tools) . To interactively draw a region, get the polygon drawing tool, then digitize a polygon over your area of interest and click **Exit** when you're done. Note that the resultant `ee.Geometry` object is automatically named geometry and added as an import at the top of your script. Rename that variable to 'polygon' by clicking on the variable name in the imports and typing the new name.

Next, get the mean pixel value in the polygon using the following code:

```{R, eval=FALSE}
## Compute the mean elevation in the polygon.
meanDict = srtm$reduceRegion(
  reducer = ee$Reducer$mean(),
  geometry = polygon,
  scale = 90
)

## Get the mean from the dictionary and print it.
mean = meanDict$get('elevation')
print('Mean elevation', mean)
```

There are several things to note here. First, observe that `reduceRegion()` is a method available for `Image` objects [learn more about reducing regions here](https://developers.google.com/earth-engine/guides/reducers_reduce_region). Second, the method arguments are provided in a R object that is passed as a single argument. (Specifically, the keys of the object are the names of the method parameters. The values are the arguments to the method). Third, the `reducer` parameter specifies the type of statistic to compute and the `geometry` parameter specifies the region in which to compute the statistic. The `scale` parameter is the pixel size in meters to use. To avoid ambiguity, you should always specify scale when doing reductions as Earth Engine may not be able to automatically determine the appropriate scale from the inputs. (Learn more about scale in Earth Engine)(https://developers.google.com/earth-engine/guides/scale).

Lastly, the return value of `reduceRegion()` is a dictionary in which keys are band names and values are the pixel statistics for the bands. The `get()` method on a dictionary returns the value corresponding to the key provided as an argument. In this case, the `srtm` image has one band, 'elevation', so the example code gets that statistic from the dictionary and prints it.

When you run this code, if you get an error that looks like:

**IMAGE**

Fear not! There are several things you can do to resolve the error. The `reduceRegion()` method has a check to make sure you consider whether you really want to include so many pixels in your computation. This is intended to prevent you from accidentally doing something silly, like trying compute the mean of every one-meter pixel in the world (don't do that). To resolve the error, either set the `bestEffort` parameter to `true` by adding `bestEffort: true` to the dictionary of parameters, or set the `maxPixels` parameter to a value higher than the default of 10 million pixels, or both. If `bestEffort` is true, Earth Engine will automatically recompute the scale such that `maxPixels` is not exceeded.

## Digression: Scale in Earth Engine {-}

In the previous example, scale is set to approximately the native resolution of the SRTM image. You can discover the native resolution of an image with:

```{R, eval=FALSE}
scale = srtm$projection()$nominalScale()
print('SRTM scale in meters', scale)
```

If you specify a scale smaller than the native resolution, Earth Engine will happily resample the input image using nearest neighbor, then include all those smaller pixels in the computation. If you set the scale to be larger, Earth Engine will use input pixels from an aggregated version of the input (i.e. get pixels from a higher level of the image pyramid). Learn more about how Earth Engine handles scale in this [doc](https://developers.google.com/earth-engine/guides/scale).

So far, you've been working with a single image with a single band. In the next page, you'll learn about multi-band images and image collections.

## Computations using Images {-}

Now that you know how to load and display an image, it's time to apply a computation to it. For example, you can compute the slope of terrain, by passing the SRTM elevation image to the `slope` [method of the] `ee.Terrain` [package](https://developers.google.com/earth-engine/apidocs/ee-terrain-slope).


# Global Forest Change {-}

## Introduction to Forest Change Analysis in Earth Engine {-}


  <figure>
      <table class="columns">
        <tr>
          <td>
            <img alt="global" class="screenshot" src="./images/chapter_03/figure_GFC_01.png"  width=100%>
          </td>
          <td>
            <img alt="Indonesia" class="screenshot" src="./images/chapter_03/figure_GFC_02.png"  width=100%>
          </td>
          <td>
            <img alt="Paraguay" class="screenshot" src="./images/chapter_03/figure_GFC_03.png"  width=100%>
          </td>
          <td>
            <img alt="Legend" class="screenshot" src="./images/chapter_03/figure_GFC_04.png"  width=100%>
          </td>
        </tr>
      </table>
      <figcaption>Figure 1. Forest change estimated by Hansen et al. (2013).  Global Change,
          2000 - 2012 (left); Change in Riau, Indonesia, 2000 - 2012 (center); Change in Paraguay,
          2000 - 2012 (right)</figcaption>
  </figure>
Welcome to the Google Earth Engine tutorial for using [Hansen et al. (2013)](http://www.sciencemag.org/content/342/6160/850) global forest cover and change data and Forest Monitoring for Action (FORMA, [Hammer et al. 2009](https://www.cgdev.org/sites/default/files/1423248_file_Hammer_Kraft_Wheeler_FORMA_FINAL.pdf)) data from [Global Forest Watch](http://www.globalforestwatch.org/). This tutorial provides examples of how to use Earth Engine to visualize these data, how to compute forest change over time and other statistics within a region of interest and how to download both the data and results of analyses.

### License and Attribution {-}

The data described in this tutorial are licensed under a Creative Commons Attribution 4.0 International License. Please use the recommended citation on the relevant [dataset description page](https://developers.google.com/earth-engine/datasets).

### Prerequisites {-}

The tutorial assumes no programming background, although it does assume a willingness to learn some programming. Before proceeding, please make sure to:
 
 - Signup for Earth Engine. Once you have been accepted, you will receive an email with additional information.
 
 - Get familiar with the [Earth Engine Rstudio](), the IDE for writing Earth Engine R code in Rstudio. Learn more [here]().
 
 - If you are unfamiliar with R, check out the [R for Earth Engine tutorial]().
 
 - If you are unfamiliar with the Earth Engine API, check out the [Introduction to the Earth Engine API]() tutorial.

Once you're familiar with R, the Earth Engine API and Rstudio, [get started on the tutorial]().

## Introduction to Hansen et al. Global Forest Change Data {-}

The [Hansen et al. (2013) Global Forest Change dataset](https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2015_v1_3) in Earth Engine represents forest change, at 30 meters resolution, globally, between 2000 and 2014. Let's start by adding the Hansen et al. data to the map. Either import the global forest change data ([learn more about searching and importing datasets]()) by searching for "Hansen forest" and naming the import **gfc2014**, or copy the following code into the Rstudio:

```{js, eval=FALSE}
var gfc2014 = ee.Image('UMD/hansen/global_forest_change_2015');
Map.addLayer(gfc2014);
```

Click on the Run button at the top of the Rstudio and you should see something like Figure 1.


Figure 1. Default visualization of Hansen et al. (2013) forest change data.

Don't worry, you'll make it look better soon. ([Learn more about default image visualizations in Earth Engine]()). By the end of this section, you'll have an image that looks something like Figure 2, where green represents where the study detected forest in the year 2000, red is estimated forest loss over the study period, blue is forest gain during that period, magenta is areas where forest has been both lost and gained, and non-forest areas are masked.

Figure 2. Custom visualization of Hansen et al. (2013) forest change data.

Recall that when a multi-band image is added to a map, the first three bands of the image are chosen as red, green, and blue, respectively, and stretched according to the data type of each band. The reason the image looks red is that the first three bands are treecover2000, loss, and gain. The treecover2000 band is expressed as a percent and has values much higher than loss (green) and gain (blue) which are binary ({0, 1}). The image therefore displays as overwhelmingly red.

The bands in the Global Forest Change data are:

   <table>
      <tr>
        <th>Band Name</th><th>Description</th><th>Range</th>
      </tr>
      <tr>
        <td>treecover2000</td><td>Percentage of tree cover in the pixel.</td><td>0 - 100</td>
      </tr>
      <tr>
        <td>loss</td><td> 1 if loss ever happen during the study period.</td><td> 0 or 1</td>
      </tr>
      <tr>
        <td>gain</td><td>1 if gain ever happen during the study period.</td><td> 0 or 1</td>
      </tr>
      <tr>
        <td>lossyear</td><td>The year loss occurred, one-indexed from year 2001, or zero if no
        loss occurred.</td><td>0 - 12</td>
      </tr>
      <tr>
        <td>first_b30</td><td>The Landsat 7 red band built from the first valid pixels in 2000
        (or older if there were no valid pixels in 2000).
        </td><td>0 - 255</td>
      </tr>
      <tr>
        <td>first_b40</td><td>The Landsat 7 near infrared band built from the first valid pixels
        in 2000.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>first_b50</td><td>The first Landsat 7 short wave infrared band built from the first
        valid pixels in 2000.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>first_b70</td><td>The second Landsat 7 short wave infrared band built from the first
        valid pixels in 2000.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>last_b30</td><td>The Landsat 7 red band built from the latest valid pixels in 2012.
        </td><td>0 - 255</td>
      </tr>
      <tr>
        <td>last_b40</td><td>The Landsat 7 near infrared band built from the latest valid pixels
        in 2012.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>last_b50</td><td>The first Landsat 7 short wave infrared band built from the latest
        valid pixels 2012.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>last_b70</td><td>The second Landsat 7 short wave infrared band built from the latest
        valid pixels 2012.</td><td>0 - 255</td>
      </tr>
      <tr>
        <td>datamask</td><td>No data (0), mapped land surface (1), and permanent water bodies
        (2).</td><td>0, 1, 2</td>
      </tr>
  </table>

To display forest cover in the year 2000 as a grayscale image, you can use the treecover2000 band, specified in the second argument to Map.addLayer():

```{js, eval=FALSE}
Map.addLayer(gfc2014, {bands: ['treecover2000']}, 'treecover2000');
```

This results in an image that should look something like Figure 3.

Figure 3. Grayscale image of year 2000 tree cover in the US.

Here's an image that uses 3 bands, Landsat bands 5, 4, and 3 for 2015. This band combination shows healthy vegetation as green and soil as mauve::

```{js, eval=FALSE}
Map.addLayer(
    gfc2014, {bands: ['last_b50', 'last_b40', 'last_b30']}, 'false color');
```

The result should look something like Figure 4.

Figure 4. Landsat 7, year 2015 false color composite of the US.

One nice visualization of the Global Forest Change dataset shows forest extent in 2000 as green, forest loss as red, and forest gain as blue. Specifically, make loss the first band (red), treecover2000 the second band (green), and gain the third band (blue):

```{js, eval=FALSE}
Map.addLayer(gfc2014, {bands: ['loss', 'treecover2000', 'gain']}, 'green');
```

The loss and gain band values are binary, so they will be barely visible on the image, which should look something like Figure 5.

Figure 5. Year 2000 tree cover in the US (green).

We'd like forest loss to show up as bright red and forest gain to show up as bright blue. To fix this, we can use the visualization parameter max to set the range to which the image data are stretched. Note that the max visualization parameter takes a list of values, corresponding to maxima for each band:

```{js, eval=FALSE}
Map.addLayer(gfc2014, {
  bands: ['loss', 'treecover2000', 'gain'],
  max: [1, 255, 1]
}, 'forest cover, loss, gain');
```

The result should look something like Figure 6.

Figure 6. US forest loss (red), year 2000 forest cover (green) and gain (blue).

This results in an image that is green where there's forest, red where there's forest loss, blue where there's forest gain, and magenta where there's both gain and loss. A closer inspection, however, reveals that it's not quite right. Instead of loss being marked as red, it's orange. This is because the bright red pixels mix with the underlying green pixels, producing orange pixels. Similarly the pixels where there's forest, loss, and gain are pink - a combination of green, bright red and bright blue. See Figure 7 for an illustration.

Figure 7. US Pacific North West forest loss (red), year 2000 cover (green) and gain (blue).

To get the image promised at the beginning of the tutorial, you can create separate images for forest, loss, gain, and for both loss and gain. Add each of these images to the map in the order that's best for display.

### Palettes {-}

To display each image as a different color, you can use the __palette__ parameter of __Map$addLayer()__ for single band images. Palettes let you set the color scheme with which the image is displayed ([learn more about palettes]()). Recall from the Earth Engine API tutorial that [the colors in a palette are linearly stretched to the __min__ and __max__]().

For example, to use a green palette to display the forest extent image, you could use:

```{js, eval=FALSE}
Map.addLayer(gfc2014, {
  bands: ['treecover2000'],
  palette: ['000000', '00FF00']
}, 'forest cover palette');
```
The result should look something like Figure 8.

Figure 8. Year 2000 forest cover in North America.

Zooming in gives a better sense for the resolution of the imagery. Figure 9 shows an area around Mariscal Estigarribia in Paraguay.

Figure 9. Year 2000 treecover around Mariscal Estigarribia in Paraguay.

The image shown in Figure 3 is a bit dark. The problem is that the __treecover2000__ band has a byte data type ([0, 255]), when in fact the values are precentages ([0, 100]). To brighten the image, you can set the __min__ and/or __max__ parameters accordingly. The palette is then stretched between those extrema.


```{js, eval=FALSE}
Map.addLayer(gfc2014, {
  bands: ['treecover2000'],
  palette: ['000000', '00FF00'],
  max: 100
}, 'forest cover percent');
```

The result should look something like Figure 9. Note that in this example, only the __max__ is set. The __min__ is zero by default.

Figure 9. Year 2000 forest cover around Mariscal Estigarribia in Paraguay, stretched to [0, 100].

### Masking {-}

All of the images shown so far have had big black areas were there the data is zero. For example, there are no trees in the ocean. To make these areas transparent, you can mask their values. Every pixel in Earth Engine has both a value and a mask. The image is rendered with transparency set by the mask, with zero being completely transparent and one being completely opaque.

You can mask an image with itself. For example, if you mask the __treecover2000__ band with itself, all the areas in which forest cover is zero will be transparent:

```{js, eval=FALSE}
Map.addLayer(gfc2014.mask(gfc2014), {
  bands: ['treecover2000'],
  palette: ['000000', '00FF00'],
  max: 100
}, 'forest cover masked');
```

The result should look something like Figure 10.

Figure 10. Year 2000 tree cover, stretched and masked.

### Example {-}

It's almost possible to make a visualization of the Hansen data like the one at the beginning of the tutorial. In this example, we're putting everything together with one small difference. Instead of specifying the bands parameter in the __Map$addLayer__ call, we're creating new images using __select()__:

```{js, eval=FALSE}
var treeCover = gfc2014.select(['treecover2000']);
var lossImage = gfc2014.select(['loss']);
var gainImage = gfc2014.select(['gain']);

// Add the tree cover layer in green.
Map.addLayer(treeCover.updateMask(treeCover),
    {palette: ['000000', '00FF00'], max: 100}, 'Forest Cover');

// Add the loss layer in red.
Map.addLayer(lossImage.updateMask(lossImage),
            {palette: ['FF0000']}, 'Loss');

// Add the gain layer in blue.
Map.addLayer(gainImage.updateMask(gainImage),
            {palette: ['0000FF']}, 'Gain');
```

The result should look something like Figure 11.

Figure 11. Forest loss (red), year 2000 cover (green) and gain (blue).

Observe that there are three __addLayer()__ calls. Each __addLayer()__ call adds a layer to the map. Mousing over the __Layers__ button in the upper right of the map reveals these layers. Each layer can be turned off or on using the checkbox next to it, and the opacity of the layer can be affected by the slider next to the layer name.

We're almost able to make the image shown at the start of the tutorial. However, the layer showing the pixels with both loss and gain is missing. It is missing because we need to know how to perform some calculations on image bands before we can calculate which pixels show both loss and gain. This is the topic of the [next section]().

## Quantifying Forest Change {-}

Let's start with the calculation needed to create a band that shows pixels where the Hansen et al. data show both loss and gain.

The Hansen et al. dataset has a band whose pixels are 1 where loss occurred and 0 otherwise (**loss**) and a band that is 1 where gain has occurred and a 0 otherwise (**gain**). To create a band where pixels in both the **loss** and the **gain** bands have a 1, you can use the **And()** logical method on images. The **And()** method is called like __image1$And(image2)__ and returns an image in which pixels are 1 where both image1 and image2 are 1, and 0 elsewhere:

```{r, eval=FALSE}
# Load the data and select the bands of interest.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossImage <-gfc2014$select('loss')
gainImage <- gfc2014$select('gain')

# Use the and() method to create the lossAndGain image.
gainAndLoss <- gainImage$And(lossImage)

# Show the loss and gain image.
Map$addLayer(gainAndLoss$updateMask(gainAndLoss),
             list(palette= 'FF00FF'), 'Gain and Loss')
```

The result, zoomed into Arkansas with satellite view, should look something like Figure 1.

<center>
<img src="C:/Users/Junior/rgeebook/images/chapter_03/figure_QFC_01.png" width=95%>
</center>

Figure 1. Pixels with forest loss and gain in Arkansas.

Combining this example with the result from the [previous section](), it's now possible to recreate the figure from the beginning of the tutorial:

```{r, eval=FALSE}
# Displaying forest, loss, gain, and pixels where both loss and gain occur.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossImage <- gfc2014$select('loss')
gainImage <- gfc2014$select('gain')
treeCover <- gfc2014$select('treecover2000')

# Use the and() method to create the lossAndGain image.
gainAndLoss <- gainImage$And(lossImage)

# Add the tree cover layer in green.
Map$addLayer(treeCover$updateMask(treeCover),
             list(palette= c('000000', '00FF00'), max= 100), 'Forest Cover')

# Add the loss layer in red.
Map$addLayer(lossImage$updateMask(lossImage),
             list(palette= 'FF0000'), 'Loss')

# Add the gain layer in blue.
Map$addLayer(gainImage$updateMask(gainImage),
             list(palette= '0000FF'), 'Gain')

# Show the loss and gain image.
Map$addLayer(gainAndLoss$updateMask(gainAndLoss),
             list(palette= 'FF00FF'), 'Gain and Loss')
```

### Quantifying Forest Change in a Region of Interest {-}

Now that you're more familiar with the bands in the Hansen et al. dataset, we can use concepts learned so far to compute statistics about forest gain and loss in a region of interest. For this we'll need to use vector data (points, lines, and polygons). A vector dataset is represented as a **FeatureCollection** in Earth Engine. (Learn more about [feature collections]() and how to [import vector data]().)

In this section, we'll compare the total amount of forest loss that happened within the Congo Republic in the year 2012 to the amount of forest loss that happened within the country's protected areas at the same time.

[As you learned in the Earth Engine API tutorial](), the key method for calculating statistics in an image region is **reduceRegion()**. ([Learn more about reducing image regions]().) For example, suppose we want to calculate the number of pixels estimated to represent forest loss during the study period. For that purpose, consider the following code:

```{r, eval=FALSE}
# Load country features from Large Scale International Boundary (LSIB) dataset.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')

# Subset the Congo Republic feature from countries.
congo <- countries$filter(ee$Filter$eq('country_na', 'Rep of the Congo'))

# Get the forest loss image.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossImage <- gfc2014$select('loss')

# Sum the values of forest loss pixels in the Congo Republic.
stats <- lossImage$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = congo,
  scale = 30
)
ee$Dictionary$getInfo(stats)
```

This example uses the __ee$Reducer$sum()__ reducer to sum the values of the pixels in **lossImage** within the **congo** feature. Because **lossImage** consists of pixels that have a value of 1 or 0 (for loss or not loss, respectively), the sum of these values is equivalent to the number of pixels of loss in the region.

Unfortunately, running the script as it is results in an error. 

The default maximum number of pixels in [**reduceRegion()**]() is 10 million. This error message indicates that the Congo Republic covers about 383 million Landsat pixels. Luckily, [**reduceRegion()**]() takes many parameters, one of which (**maxPixels**) lets you control how many pixels are used in the computation. Specifying this parameter allows the computation to succeed:

```{r, eval=FALSE}
# Load country features from Large Scale International Boundary (LSIB) dataset.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')

# Subset the Congo Republic feature from countries.
congo <- countries$filter(ee$Filter$eq('country_na', 'Rep of the Congo'))

# Get the forest loss image.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossImage <- gfc2014$select('loss')

# Sum the values of forest loss pixels in the Congo Republic.
stats <- lossImage$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = congo,
  scale = 30,
  maxPixels = 1e9
)
ee$Dictionary$getInfo(stats)
```

By expanding the object printed to the console, observe that the result is 4897933 pixels of forest lost. You can clean up the printout in the console a bit by labeling the output and getting the result of interest from the dictionary returned by **reduceRegion()**:

```{r, eval=FALSE}
print(paste0("pixels representing loss: ", ee$Dictionary$getInfo(stats$get('loss'))))
```

### Calculating Pixel Areas {-}

You're almost ready to answer the question of how much area was lost in the Congo Republic, and how much of that was in protected areas. The remaining part is to convert pixels into actual area. This conversion is important because we don't necessarily know the size of the pixels input to **reduceRegion()**. To help compute areas, Earth Engine has the __ee$Image$pixelArea()__ method which generates an image in which the value of each pixel is the pixel's area in square meters. Multiplying the loss image with this area image and then summing over the result gives us a measure of area:

```{r, eval=FALSE}
# Load country features from Large Scale International Boundary (LSIB) dataset.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')

# Subset the Congo Republic feature from countries.
congo <- countries$filter(ee$Filter$eq('country_na', 'Rep of the Congo'))

# Get the forest loss image.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossImage <- gfc2014$select('loss')
areaImage <- lossImage$multiply(ee$Image$pixelArea())

# Sum the values of forest loss pixels in the Congo Republic.
stats <- areaImage$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = congo,
  scale = 30,
  maxPixels = 1e9
)

print(paste0("pixels representing loss: ", ee$Dictionary$getInfo(stats$get('loss')), " square meters"))
```

Now the result is 4,372,566,344 square meters lost over the study period.

You are now ready to answer the question at the start of this section - how much forest area was lost in the Congo Republic in 2012, and how much of that was in protected areas?

```{r, eval=FALSE}
# Load country features from Large Scale International Boundary (LSIB) dataset.
countries <-  ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')

# Subset the Congo Republic feature from countries.
congo <- ee$Feature(
  countries
  $filter(ee$Filter$eq('country_na', 'Rep of the Congo'))
  $first()
)

# Subset protected areas to the bounds of the congo feature
# and other criteria. Clip to the intersection with congo.
protectedAreas <- ee$FeatureCollection('WCMC/WDPA/current/polygons')$filter(ee$Filter$And(
  ee$Filter$bounds(congo$geometry()),
  ee$Filter$neq('IUCN_CAT', 'VI'),
  ee$Filter$neq('STATUS', 'proposed'),
  ee$Filter$lt('STATUS_YR', 2010)
))
$map(function(feat){
  return(congo$intersection(feat))
})

# Get the loss image.
gfc2014 <- ee$Image('UMD/hansen/global_forest_change_2015')
lossIn2012 <- gfc2014$select('lossyear')$eq(12)
areaImage <- lossIn2012$multiply(ee$Image$pixelArea())

# Calculate the area of loss pixels in the Congo Republic.
stats <- areaImage$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = congo$geometry(),
  scale = 30,
  maxPixels = 1e9
)

print(paste0("Area lost in the Congo Republic: ", 
             ee$Dictionary$getInfo(stats$get('lossyear')),
             " square meters")) 

# Calculate the area of loss pixels in the protected areas.
stats <- areaImage$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = protectedAreas$geometry(),
  scale = 30,
  maxPixels = 1e9
)

print(paste0("Area lost in protected areas: ", 
             ee$Dictionary$getInfo(stats$get('lossyear')), 
             " square meters")) 
```
The output indicates that of the 348,036,295 square meters of forest lost in the Congo Republic in 2012, 11,880,976 of those were in protected areas, as represented in the [World Database on Protected Areas table]().

The only changes between this script and the one just prior are the addition of the protected area information and changing the script from looking at overall loss to looking at loss in 2012. This required two changes. First, there's a new **lossIn2012** image which has a 1 where loss was recorded in 2012, 0 otherwise. Second, because the name of the band is different (**lossyear** instead of **loss**) the property name had to change in the print statement.

In the [next section](), we will explore some advanced methods for computing and charting forest loss for every year, instead of just one year as we did in this section.

## Charting Yearly Forest Loss {-}

### Calculating Yearly Forest Loss {-}

In the previous section you learned how to [calculate total forest area lost]() in the given region of interest using the **reduceRegion** method. Instead of calculating the total loss, it would be helpful to compute the loss for each year. The way to achieve this in Earth Engine is using a [Grouped Reducer]().

To group output of **reduceRegion()**, you can specify a grouping band that defines groups by integer pixel values. In the following example, we slightly modify the previous code and add the **lossYear** band to the original image. Each pixel in the **lossYear** band contain values from 0 to 14 - indicating the year in which the loss occurred. We also change the reducer to a grouped reducer, specifying the band index of the grouping band (1) so the pixel areas will be summed and grouped according to the value in the **lossYear** band.

```{r, eval=FALSE}
# Load country boundaries from LSIB.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')
# Get a feature collection with just the Congo feature.
congo <- countries$filter(ee$Filter$eq('country_co', 'CF'))

# Get the loss image.
# This dataset is updated yearly, so we get the latest version.
gfc2017 <- ee$Image('UMD/hansen/global_forest_change_2017_v1_5')
lossImage <- gfc2017$select('loss')
lossAreaImage <- lossImage$multiply(ee$Image$pixelArea())

lossYear <- gfc2017$select('lossyear')
lossByYear <- lossAreaImage$addBands(lossYear)$reduceRegion(
  reducer = ee$Reducer$sum()$group(
    groupField = 1
  ),
  geometry = congo,
  scale = 30,
  maxPixels = 1e9
)

print(paste0(ee$Dictionary$getInfo(lossByYear)) 
```

Once you run the above code, you will see the yearly forest loss area printed out in a nested list called **groups**. We can format the output a little to make the result a dictionary, with year as the key and loss area as the value. Notice that we are using the **format()** method to convert the year values from 0-14 to 2000-2014.

```{r, eval=FALSE}
# Load country boundaries from LSIB.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')
# Get a feature collection with just the Congo feature.
congo <- countries$filter(ee$Filter$eq('country_co', 'CF'))

# Get the loss image.
# This dataset is updated yearly, so we get the latest version.
gfc2017 <- ee$Image('UMD/hansen/global_forest_change_2017_v1_5')
lossImage <- gfc2017$select('loss')
lossAreaImage <- lossImage$multiply(ee$Image$pixelArea())

lossYear <- gfc2017$select('lossyear')
lossByYear <- lossAreaImage$addBands(lossYear)$reduceRegion(
  reducer = ee$Reducer$sum()$group(
    groupField = 1
  ),
  geometry = congo,
  scale = 30,
  maxPixels = 1e9
)

statsFormatted <- ee$List(lossByYear$get('groups'))$map(function(el){
  d <- ee$Dictionary(el)
  return (c(ee$Number(d$get('group'))$format("20%02d"), d$get('sum')))
})

statsDictionary <- ee$Dictionary(statsFormatted$flatten())

print(paste0(ee$Dictionary$getInfo(statsDictionary))
```

### Making a chart {-}

## Introduction to Forest Monitoring for Action (FORMA) data {-}

FORMA is a [MODIS](http://modis.gsfc.nasa.gov/about/) based 500 x 500 meter twice-monthly deforestation alerting system for the humid tropical forests. The [FORMA 500 dataset](https://developers.google.com/earth-engine/datasets/catalog/FORMA_FORMA_500m) in Earth Engine is an image with alerts starting in January 2006 and updated monthly. Each alert has a time associated with it in a single band named **alert_date** in units of [epoch seconds](https://en.wikipedia.org/wiki/Unix_time). Filtering FORMA by dates and calculating alerts within areas of interest are two of the most important things you can do with the FORMA dataset.

### Filtering FORMA by Date {-}

To show just those alerts that occur in 2012, find pixels that have times between the first day of 2012 and the first day of 2013, expressed in seconds since midnight, January 1, 1970:

```{r, eval=FALSE}
# Convert dates from milliseconds to seconds.
start <- ee$Date('2012-01-01')$millis()$divide(1000)
end <- ee$Date('2013-01-01')$millis()$divide(1000)

# Load the FORMA 500 dataset.
forma <- ee$Image('FORMA/FORMA_500m')

# Create a binary layer from the dates of interest.
forma2012 <- forma$gte(start)$And(forma$lte(end))

Map$setCenter(15.87, -0.391, 7)
Map$addLayer(
  forma2012$mask(forma2012),
  list(palette = 'FF0000'),
  'FORMA alerts in 2012'
)
```

In this example, **forma2012** is a binary image containing only those pixels that have times occurring in 2012 (i.e. all other pixels are masked).

### Counting FORMA Alerts in a Region of Interest {-}

[As we did in the previous section]() with the Hansen et al. data, we can start by counting the number of FORMA alerts (pixels) in an area of interest. For example, to count the number of alerts in protected areas of the Congo Republic in 2012, build on the previous example as follows:

```{r, eval=FALSE}
# Load country features from Large Scale International Boundary (LSIB) dataset.
countries <- ee$FeatureCollection('USDOS/LSIB_SIMPLE/2017')

# Subset the Congo Republic feature from countries.
congo <- ee$Feature(
  countries$
    filter(ee$Filter$eq('country_na', 'Rep of the Congo'))$
    first()
)

# Subset protected areas to the bounds of the congo feature
# and other criteria. Clip to the intersection with congo.
protectedAreas <- ee$FeatureCollection('WCMC/WDPA/current/polygons')$
  filter(ee$Filter$And(
  ee$Filter$bounds(congo$geometry()),
  ee$Filter$neq('IUCN_CAT', 'VI'),
  ee$Filter$neq('STATUS', 'proposed'),
  ee$Filter$lt('STATUS_YR', 2010)
))$map(function(feat){
  return(congo$intersection(feat))
})

# Display protected areas on the map.
Map$addLayer(
  protectedAreas,
  list(color = '000000'),
  'Congo Republic protected areas'
)

# Calculate the number of FORMA pixels in protected
# areas of the Congo Republic, 2012.
stats <- forma2012$reduceRegion(
  reducer = ee$Reducer$sum(),
  geometry = protectedAreas$geometry(),
  scale = 500
)

print(paste0('Number of FORMA pixels, 2012: ', ee$Dictionary$getInfo(stats.get('constant')))
```

### Counting FORMA Alerts in Several Regions of Interest {-}
So far, we've been computing statistics in a single region at a time. For computing statistics in multiple regions at once, you can use **reduceRegions()**. Again building on the previous example:

```{r, eval=FALSE}

regionsStats <- forma2012$reduceRegions(
  collection = protectedAreas,
  reducer = ee$Reducer$sum(),
  scale = forma2012$projection()$nominalScale()
)

print(ee$Dictionary$getInfo(regionsStats))
      
```

Examine the object printed to the console and observe that the output of **reduceRegions()** is another **FeatureCollection**. Note that every region in the collection of the Congo Republic protected areas now has an additional property, **sum**, named after the reducer. The value of this property is the output of the reducer, or the number of 2012 alerts in the protected areas.

#### Comparing FORMA and Hansen et al. Datasets {-}

To compare the FORMA and Hansen et al. datasets, you can use logical operators. ([Learn more about logical operations]()). Specifically, we'd like to make an image in which pixels marked by both FORMA and the Hansen et al. data as deforestation are 1 and the rest are zero. This code makes such an image for 2012 and displays it along with other predicted deforestation layers:

```{r, eval=FALSE}
# Convert dates from milliseconds to seconds.
start <- ee$Date('2012-01-01')$millis()$divide(1000)
end <- ee$Date('2013-01-01')$millis()$divide(1000)
region <- ee$Geometry$Rectangle(c(-59.81163, -9.43348, -59.27561, -9.22818))

# Load the FORMA 500 dataset.
forma <- ee$Image('FORMA/FORMA_500m')

# Create a binary layer from the dates of interest.
forma2012 <- forma$gte(start)$and(forma$lte(end))

# Load Hansen et al. data and get change in 2012.
gfc <- ee$Image('UMD/hansen/global_forest_change_2015')
gfc12 <- gfc$select('lossyear')$eq(12)

# Create an image which is one where the datasets
# both show deforestation and zero elsewhere.
gfc_forma <- gfc12$eq(1)$and(forma2012$eq(1))

# Display data on the map.
Map$setCenter(-59.58813, -9.36439, 11)
Map$addLayer(forma$updateMask(forma), list(palette = '00FF00'), 'Forma (green)')
Map$addLayer(gfc12$updateMask(gfc12), list(palette = 'FF0000'), 'Hansen (red)')
Map$addLayer(
  gfc_forma$updateMask(gfc_forma),
  list(palette = 'FFFF00'),
  'Hansen & FORMA (yellow)'
)
```

This concludes the overview of forest change datasets in Earth Engine. We're looking forward to seeing what you can do with them!

# Global Surface Water {-}

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!

# Video Tutorials

To start your journey in mastering R, the following six chapters will help you learn the foundational components of R. I expect that you've already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!
